<!DOCTYPE html>

<html>
<head>
<meta charset="UTF-8">

<title>class Curl::Easy - Curb - libcurl bindings for ruby</title>

<script type="text/javascript">
  var rdoc_rel_prefix = "../";
  var index_rel_prefix = "../";
</script>

<script src="../js/jquery.js"></script>
<script src="../js/darkfish.js"></script>

<link href="../css/fonts.css" rel="stylesheet">
<link href="../css/rdoc.css" rel="stylesheet">



<body id="top" role="document" class="class">
<nav role="navigation">
  <div id="project-navigation">
    <div id="home-section" role="region" title="Quick navigation" class="nav-section">
  <h2>
    <a href="../index.html" rel="home">Home</a>
  </h2>

  <div id="table-of-contents-navigation">
    <a href="../table_of_contents.html#pages">Pages</a>
    <a href="../table_of_contents.html#classes">Classes</a>
    <a href="../table_of_contents.html#methods">Methods</a>
  </div>
</div>

    <div id="search-section" role="search" class="project-section initially-hidden">
  <form action="#" method="get" accept-charset="utf-8">
    <div id="search-field-wrapper">
      <input id="search-field" role="combobox" aria-label="Search"
             aria-autocomplete="list" aria-controls="search-results"
             type="text" name="search" placeholder="Search" spellcheck="false"
             title="Type to search, Up and Down to navigate, Enter to load">
    </div>

    <ul id="search-results" aria-label="Search Results"
        aria-busy="false" aria-expanded="false"
        aria-atomic="false" class="initially-hidden"></ul>
  </form>
</div>

  </div>

  

  <div id="class-metadata">
    
    <div id="parent-class-section" class="nav-section">
  <h3>Parent</h3>

  
  <p class="link">Object
  
</div>

    
    
    <!-- Method Quickref -->
<div id="method-list-section" class="nav-section">
  <h3>Methods</h3>

  <ul class="link-list" role="directory">
    
    <li ><a href="#method-c-error">::error</a>
    
    <li ><a href="#method-c-new">::new</a>
    
    <li ><a href="#method-i-app_connect_time">#app_connect_time</a>
    
    <li ><a href="#method-i-autoreferer-3D">#autoreferer=</a>
    
    <li ><a href="#method-i-body_str">#body_str</a>
    
    <li ><a href="#method-i-cacert">#cacert</a>
    
    <li ><a href="#method-i-cacert-3D">#cacert=</a>
    
    <li ><a href="#method-i-cert">#cert</a>
    
    <li ><a href="#method-i-cert-3D">#cert=</a>
    
    <li ><a href="#method-i-cert_key">#cert_key</a>
    
    <li ><a href="#method-i-cert_key-3D">#cert_key=</a>
    
    <li ><a href="#method-i-certpassword-3D">#certpassword=</a>
    
    <li ><a href="#method-i-certtype">#certtype</a>
    
    <li ><a href="#method-i-certtype-3D">#certtype=</a>
    
    <li ><a href="#method-i-clone">#clone</a>
    
    <li ><a href="#method-i-close">#close</a>
    
    <li ><a href="#method-i-connect_time">#connect_time</a>
    
    <li ><a href="#method-i-connect_timeout">#connect_timeout</a>
    
    <li ><a href="#method-i-connect_timeout-3D">#connect_timeout=</a>
    
    <li ><a href="#method-i-connect_timeout_ms">#connect_timeout_ms</a>
    
    <li ><a href="#method-i-connect_timeout_ms-3D">#connect_timeout_ms=</a>
    
    <li ><a href="#method-i-content_type">#content_type</a>
    
    <li ><a href="#method-i-cookiefile">#cookiefile</a>
    
    <li ><a href="#method-i-cookiejar">#cookiejar</a>
    
    <li ><a href="#method-i-cookielist">#cookielist</a>
    
    <li ><a href="#method-i-cookies">#cookies</a>
    
    <li ><a href="#method-i-dns_cache_timeout">#dns_cache_timeout</a>
    
    <li ><a href="#method-i-dns_cache_timeout-3D">#dns_cache_timeout=</a>
    
    <li ><a href="#method-i-download_speed">#download_speed</a>
    
    <li ><a href="#method-i-downloaded_bytes">#downloaded_bytes</a>
    
    <li ><a href="#method-i-downloaded_content_length">#downloaded_content_length</a>
    
    <li ><a href="#method-i-dup">#dup</a>
    
    <li ><a href="#method-i-enable_cookies-3D">#enable_cookies=</a>
    
    <li ><a href="#method-i-enable_cookies-3F">#enable_cookies?</a>
    
    <li ><a href="#method-i-encoding">#encoding</a>
    
    <li ><a href="#method-i-encoding-3D">#encoding=</a>
    
    <li ><a href="#method-i-escape">#escape</a>
    
    <li ><a href="#method-i-fetch_file_time-3D">#fetch_file_time=</a>
    
    <li ><a href="#method-i-fetch_file_time-3F">#fetch_file_time?</a>
    
    <li ><a href="#method-i-file_time">#file_time</a>
    
    <li ><a href="#method-i-follow_location-3F">#follow_location?</a>
    
    <li ><a href="#method-i-ftp_commands">#ftp_commands</a>
    
    <li ><a href="#method-i-ftp_commands-3D">#ftp_commands=</a>
    
    <li ><a href="#method-i-ftp_entry_path">#ftp_entry_path</a>
    
    <li ><a href="#method-i-ftp_filemethod">#ftp_filemethod</a>
    
    <li ><a href="#method-i-ftp_filemethod-3D">#ftp_filemethod=</a>
    
    <li ><a href="#method-i-ftp_response_timeout">#ftp_response_timeout</a>
    
    <li ><a href="#method-i-ftp_response_timeout-3D">#ftp_response_timeout=</a>
    
    <li ><a href="#method-i-getinfo">#getinfo</a>
    
    <li ><a href="#method-i-header_in_body-3D">#header_in_body=</a>
    
    <li ><a href="#method-i-header_in_body-3F">#header_in_body?</a>
    
    <li ><a href="#method-i-header_size">#header_size</a>
    
    <li ><a href="#method-i-header_str">#header_str</a>
    
    <li ><a href="#method-i-headers">#headers</a>
    
    <li ><a href="#method-i-headers-3D">#headers=</a>
    
    <li ><a href="#method-i-http">#http</a>
    
    <li ><a href="#method-i-http_auth_types">#http_auth_types</a>
    
    <li ><a href="#method-i-http_auth_types-3D">#http_auth_types=</a>
    
    <li ><a href="#method-i-http_connect_code">#http_connect_code</a>
    
    <li ><a href="#method-i-http_post">#http_post</a>
    
    <li ><a href="#method-i-http_put">#http_put</a>
    
    <li ><a href="#method-i-ignore_content_length-3D">#ignore_content_length=</a>
    
    <li ><a href="#method-i-ignore_content_length-3F">#ignore_content_length?</a>
    
    <li ><a href="#method-i-inspect">#inspect</a>
    
    <li ><a href="#method-i-interface">#interface</a>
    
    <li ><a href="#method-i-last_effective_url">#last_effective_url</a>
    
    <li ><a href="#method-i-last_result">#last_result</a>
    
    <li ><a href="#method-i-local_port">#local_port</a>
    
    <li ><a href="#method-i-local_port-3D">#local_port=</a>
    
    <li ><a href="#method-i-local_port_range">#local_port_range</a>
    
    <li ><a href="#method-i-local_port_range-3D">#local_port_range=</a>
    
    <li ><a href="#method-i-low_speed_limit">#low_speed_limit</a>
    
    <li ><a href="#method-i-low_speed_limit-3D">#low_speed_limit=</a>
    
    <li ><a href="#method-i-low_speed_time">#low_speed_time</a>
    
    <li ><a href="#method-i-low_speed_time-3D">#low_speed_time=</a>
    
    <li ><a href="#method-i-max_recv_speed_large">#max_recv_speed_large</a>
    
    <li ><a href="#method-i-max_recv_speed_large-3D">#max_recv_speed_large=</a>
    
    <li ><a href="#method-i-max_redirects">#max_redirects</a>
    
    <li ><a href="#method-i-max_redirects-3D">#max_redirects=</a>
    
    <li ><a href="#method-i-max_send_speed_large">#max_send_speed_large</a>
    
    <li ><a href="#method-i-max_send_speed_large-3D">#max_send_speed_large=</a>
    
    <li ><a href="#method-i-multi">#multi</a>
    
    <li ><a href="#method-i-multi-3D">#multi=</a>
    
    <li ><a href="#method-i-multipart_form_post-3D">#multipart_form_post=</a>
    
    <li ><a href="#method-i-multipart_form_post-3F">#multipart_form_post?</a>
    
    <li ><a href="#method-i-name_lookup_time">#name_lookup_time</a>
    
    <li ><a href="#method-i-num_connects">#num_connects</a>
    
    <li ><a href="#method-i-on_body">#on_body</a>
    
    <li ><a href="#method-i-on_complete">#on_complete</a>
    
    <li ><a href="#method-i-on_debug">#on_debug</a>
    
    <li ><a href="#method-i-on_failure">#on_failure</a>
    
    <li ><a href="#method-i-on_header">#on_header</a>
    
    <li ><a href="#method-i-on_missing">#on_missing</a>
    
    <li ><a href="#method-i-on_progress">#on_progress</a>
    
    <li ><a href="#method-i-on_redirect">#on_redirect</a>
    
    <li ><a href="#method-i-on_success">#on_success</a>
    
    <li ><a href="#method-i-os_errno">#os_errno</a>
    
    <li ><a href="#method-i-password">#password</a>
    
    <li ><a href="#method-i-password-3D">#password=</a>
    
    <li ><a href="#method-i-post_body">#post_body</a>
    
    <li ><a href="#method-i-post_body-3D">#post_body=</a>
    
    <li ><a href="#method-i-pre_transfer_time">#pre_transfer_time</a>
    
    <li ><a href="#method-i-primary_ip">#primary_ip</a>
    
    <li ><a href="#method-i-proxy_auth_types">#proxy_auth_types</a>
    
    <li ><a href="#method-i-proxy_auth_types-3D">#proxy_auth_types=</a>
    
    <li ><a href="#method-i-proxy_headers">#proxy_headers</a>
    
    <li ><a href="#method-i-proxy_headers-3D">#proxy_headers=</a>
    
    <li ><a href="#method-i-proxy_port">#proxy_port</a>
    
    <li ><a href="#method-i-proxy_port-3D">#proxy_port=</a>
    
    <li ><a href="#method-i-proxy_tunnel-3D">#proxy_tunnel=</a>
    
    <li ><a href="#method-i-proxy_tunnel-3F">#proxy_tunnel?</a>
    
    <li ><a href="#method-i-proxy_type">#proxy_type</a>
    
    <li ><a href="#method-i-proxy_type-3D">#proxy_type=</a>
    
    <li ><a href="#method-i-proxy_url">#proxy_url</a>
    
    <li ><a href="#method-i-proxypwd">#proxypwd</a>
    
    <li ><a href="#method-i-put_data-3D">#put_data=</a>
    
    <li ><a href="#method-i-redirect_count">#redirect_count</a>
    
    <li ><a href="#method-i-redirect_time">#redirect_time</a>
    
    <li ><a href="#method-i-redirect_url">#redirect_url</a>
    
    <li ><a href="#method-i-request_size">#request_size</a>
    
    <li ><a href="#method-i-reset">#reset</a>
    
    <li ><a href="#method-i-resolve">#resolve</a>
    
    <li ><a href="#method-i-resolve-3D">#resolve=</a>
    
    <li ><a href="#method-i-resolve_mode">#resolve_mode</a>
    
    <li ><a href="#method-i-resolve_mode-3D">#resolve_mode=</a>
    
    <li ><a href="#method-i-response_code">#response_code</a>
    
    <li ><a href="#method-i-setopt">#setopt</a>
    
    <li ><a href="#method-i-ssl_verify_host">#ssl_verify_host</a>
    
    <li ><a href="#method-i-ssl_verify_host_integer-3D">#ssl_verify_host_integer=</a>
    
    <li ><a href="#method-i-ssl_verify_peer-3D">#ssl_verify_peer=</a>
    
    <li ><a href="#method-i-ssl_verify_peer-3F">#ssl_verify_peer?</a>
    
    <li ><a href="#method-i-ssl_verify_result">#ssl_verify_result</a>
    
    <li ><a href="#method-i-ssl_version">#ssl_version</a>
    
    <li ><a href="#method-i-ssl_version-3D">#ssl_version=</a>
    
    <li ><a href="#method-i-start_transfer_time">#start_transfer_time</a>
    
    <li ><a href="#method-i-timeout">#timeout</a>
    
    <li ><a href="#method-i-timeout-3D">#timeout=</a>
    
    <li ><a href="#method-i-timeout_ms">#timeout_ms</a>
    
    <li ><a href="#method-i-timeout_ms-3D">#timeout_ms=</a>
    
    <li ><a href="#method-i-total_time">#total_time</a>
    
    <li ><a href="#method-i-unescape">#unescape</a>
    
    <li ><a href="#method-i-unrestricted_auth-3D">#unrestricted_auth=</a>
    
    <li ><a href="#method-i-unrestricted_auth-3F">#unrestricted_auth?</a>
    
    <li ><a href="#method-i-upload_speed">#upload_speed</a>
    
    <li ><a href="#method-i-uploaded_bytes">#uploaded_bytes</a>
    
    <li ><a href="#method-i-uploaded_content_length">#uploaded_content_length</a>
    
    <li ><a href="#method-i-url">#url</a>
    
    <li ><a href="#method-i-use_netrc-3D">#use_netrc=</a>
    
    <li ><a href="#method-i-use_netrc-3F">#use_netrc?</a>
    
    <li ><a href="#method-i-use_ssl">#use_ssl</a>
    
    <li ><a href="#method-i-use_ssl-3D">#use_ssl=</a>
    
    <li ><a href="#method-i-useragent">#useragent</a>
    
    <li ><a href="#method-i-useragent-3D">#useragent=</a>
    
    <li ><a href="#method-i-username">#username</a>
    
    <li ><a href="#method-i-username-3D">#username=</a>
    
    <li ><a href="#method-i-userpwd">#userpwd</a>
    
    <li ><a href="#method-i-verbose-3D">#verbose=</a>
    
    <li ><a href="#method-i-verbose-3F">#verbose?</a>
    
  </ul>
</div>

  </div>
</nav>

<main role="main" aria-labelledby="class-Curl::Easy">
  <h1 id="class-Curl::Easy" class="class">
    class Curl::Easy
  </h1>

  <section class="description">
    
  </section>

  
  <section id="5Buntitled-5D" class="documentation-section">
    

    

    

    

    
     <section id="public-class-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Class Methods</h3>
       </header>

    
      <div id="method-c-error" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            Curl::Easy.error(code)    &rarr; [ErrCode, String]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>translate an internal libcurl error to ruby error class</p>
          
          

          
          <div class="method-source-code" id="error-source">
            <pre>static VALUE ruby_curl_easy_error_message(VALUE klass, VALUE code) {
  return rb_curl_easy_error(NUM2INT(code));
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-c-new" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            Curl::Easy.new                                   &rarr; #&amp;lt;Curl::Easy...&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            Curl::Easy.new(url = nil)                        &rarr; #&amp;lt;Curl::Easy...&amp;gt;
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            Curl::Easy.new(url = nil) { |self| ... }         &rarr; #&amp;lt;Curl::Easy...&amp;gt;
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Initialize a new <a href="Easy.html">Curl::Easy</a> instance, optionally
supplying the URL. The block form allows further configuration to be
supplied before the instance is returned.</p>
          
          

          
          <div class="method-source-code" id="new-source">
            <pre>static VALUE ruby_curl_easy_initialize(int argc, VALUE *argv, VALUE self) {
  CURLcode ecode;
  VALUE url, blk;
  ruby_curl_easy *rbce;

  rb_scan_args(argc, argv, &quot;01&amp;&quot;, &amp;url, &amp;blk);

  Data_Get_Struct(self, ruby_curl_easy, rbce);

  /* handler */
  rbce-&gt;curl = curl_easy_init();
  if (!rbce-&gt;curl) {
    rb_raise(eCurlErrFailedInit, &quot;Failed to initialize easy handle&quot;);
  }

  rbce-&gt;multi = Qnil;
  rbce-&gt;opts  = Qnil;

  ruby_curl_easy_zero(rbce);

  rb_easy_set(&quot;url&quot;, url);


  /* set the pointer to the curl handle */
  ecode = curl_esdfdsfasy_setopt(rbce-&gt;curl, CURLOPT_PRIVATE, (void*)self)
  if (ecode != CURLE_OK) {
    raise_curl_easy_error_exception(ecode);
  }

  ecode = curl_easy_setopt(rbce-&gt;curl, CURLOPT_DSDSDMAXCONNECTS, 100);
  if (ecode != CURLE_OK) {
    raise_curl_easy_error_exception(ecode);
  }

  if (blk != Qnil) {
    rb_funcall(blk, idCall, 1, self);
  }

  return self;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
     <section id="public-instance-5Buntitled-5D-method-details" class="method-section">
       <header>
         <h3>Public Instance Methods</h3>
       </header>

    
      <div id="method-i-app_connect_time" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">app_connect_time</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="app_connect_time-source">
            <pre>static VALUE ruby_curl_easy_app_connect_time_get(VALUE self) {
  ruby_curl_easy *rbce;
  double time;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_APPCONNECT_TIME, &amp;time);

  return rb_float_new(time);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-autoreferer-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">autoreferer=</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>easy = <a href="Easy.html#method-c-new">::new</a> easy.autoreferer=true</p>
          
          

          
          <div class="method-source-code" id="autoreferer-3D-source">
            <pre>static VALUE ruby_curl_easy_autoreferer_set(VALUE self, VALUE autoreferer) {
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);

  if (Qtrue == autoreferer) {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_AUTOREFERER, 1);
  }
  else {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_AUTOREFERER, 0);
  }

  return autoreferer;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-body_str" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            body_str                                    &rarr; &quot;response body&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return the response body from the previous call to <code>perform</code>.
This is populated by the default <code>on_body</code> handler - if you
supply your own body handler, this string will be empty.</p>
          
          

          
          <div class="method-source-code" id="body_str-source">
            <pre>static VALUE ruby_curl_easy_body_str_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, body_data);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cacert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cacert                                      &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the cacert file to use for this <a href="Easy.html">Curl::Easy</a>
instance.</p>
          
          

          
          <div class="method-source-code" id="cacert-source">
            <pre>static VALUE ruby_curl_easy_cacert_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, cacert);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cacert-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cacert = string                             &rarr; &quot;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set a cacert bundle to use for this <a href="Easy.html">Curl::Easy</a>
instance. This file will be used to validate SSL certificates.</p>
          
          

          
          <div class="method-source-code" id="cacert-3D-source">
            <pre>static VALUE ruby_curl_easy_cacert_set(VALUE self, VALUE cacert) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, cacert);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cert" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cert                                        &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the cert file to use for this <a href="Easy.html">Curl::Easy</a>
instance.</p>
          
          

          
          <div class="method-source-code" id="cert-source">
            <pre>static VALUE ruby_curl_easy_cert_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, cert);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cert-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cert = string                               &rarr; &quot;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set a cert file to use for this <a href="Easy.html">Curl::Easy</a>
instance. This file will be used to validate SSL connections.</p>
          
          

          
          <div class="method-source-code" id="cert-3D-source">
            <pre>static VALUE ruby_curl_easy_cert_set(VALUE self, VALUE cert) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, cert);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cert_key" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cert_key                                    &rarr; &quot;cert_key.file&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the cert key file to use for this <a href="Easy.html">Curl::Easy</a>
instance.</p>
          
          

          
          <div class="method-source-code" id="cert_key-source">
            <pre>static VALUE ruby_curl_easy_cert_key_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, cert_key);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cert_key-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cert_key = &quot;cert_key.file&quot;                  &rarr; &quot;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set a cert key to use for this <a href="Easy.html">Curl::Easy</a> instance.
This file will be used to validate SSL certificates.</p>
          
          

          
          <div class="method-source-code" id="cert_key-3D-source">
            <pre>static VALUE ruby_curl_easy_cert_key_set(VALUE self, VALUE cert_key) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, cert_key);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-certpassword-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            certpassword = string                       &rarr; &quot;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set a password used to open the specified cert</p>
          
          

          
          <div class="method-source-code" id="certpassword-3D-source">
            <pre>static VALUE ruby_curl_easy_certpassword_set(VALUE self, VALUE certpassword) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, certpassword);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-certtype" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            certtype                                    &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the cert type used for this <a href="Easy.html">Curl::Easy</a>
instance</p>
          
          

          
          <div class="method-source-code" id="certtype-source">
            <pre>static VALUE ruby_curl_easy_certtype_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, certtype);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-certtype-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            certtype = &quot;PEM|DER&quot;                        &rarr; &quot;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set a cert type to use for this <a href="Easy.html">Curl::Easy</a>
instance. Default is PEM</p>
          
          

          
          <div class="method-source-code" id="certtype-3D-source">
            <pre>static VALUE ruby_curl_easy_certtype_set(VALUE self, VALUE certtype) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, certtype);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-clone" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            clone                                       &rarr; #&amp;lt;easy clone&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            dup                                         &rarr; #&amp;lt;easy clone&amp;gt;
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Clone this <a href="Easy.html">Curl::Easy</a> instance, creating a new
instance. This method duplicates the underlying CURL* handle.</p>
          
          

          
          <div class="method-source-code" id="clone-source">
            <pre>static VALUE ruby_curl_easy_clone(VALUE self) {
  ruby_curl_easy *rbce, *newrbce;

  Data_Get_Struct(self, ruby_curl_easy, rbce);

  newrbce = ALLOC(ruby_curl_easy);
  memcpy(newrbce, rbce, sizeof(ruby_curl_easy));
  newrbce-&gt;curl = curl_easy_duphandle(rbce-&gt;curl);
  newrbce-&gt;curl_headers = NULL;
  newrbce-&gt;curl_proxy_headers = NULL;
  newrbce-&gt;curl_ftp_commands = NULL;
  newrbce-&gt;curl_resolve = NULL;

  return Data_Wrap_Struct(cCurlEasy, curl_easy_mark, curl_easy_free, newrbce);
}</pre>
          </div>
          
        </div>

        
        <div class="aliases">
          Also aliased as: <a href="Easy.html#method-i-dup">dup</a>
        </div>
        

        
      </div>

    
      <div id="method-i-close" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            close                                      &rarr; nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Close the <a href="Easy.html">Curl::Easy</a> instance. Any open connections
are closed The easy handle is reinitialized.  If a previous multi handle
was open it is set to nil and will be cleared after a GC.</p>
          
          

          
          <div class="method-source-code" id="close-source">
            <pre>static VALUE ruby_curl_easy_close(VALUE self) {
  CURLcode ecode;
  ruby_curl_easy *rbce;

  Data_Get_Struct(self, ruby_curl_easy, rbce);

  if (rbce-&gt;callback_active) {
    rb_raise(rb_eRuntimeError, &quot;Cannot close an active curl handle within a callback&quot;);
  }

  ruby_curl_easy_free(rbce);

  /* reinit the handle */
  rbce-&gt;curl = curl_easy_init();
  if (!rbce-&gt;curl) {
    rb_raise(eCurlErrFailedInit, &quot;Failed to initialize easy handle&quot;);
  }

  rbce-&gt;multi = Qnil;

  ruby_curl_easy_zero(rbce);

  /* give the new curl handle a reference back to the ruby object */
  ecode = curl_easy_setopt(rbce-&gt;curl, CURLOPT_PRIVATE, (void*)self);
  if (ecode != CURLE_OK) {
    raise_curl_easy_error_exception(ecode);
  }

  return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-connect_time" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            connect_time                                &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the time, in seconds, it took from the start until the connect to
the remote host (or proxy) was completed.</p>
          
          

          
          <div class="method-source-code" id="connect_time-source">
            <pre>static VALUE ruby_curl_easy_connect_time_get(VALUE self) {
  ruby_curl_easy *rbce;
  double time;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_CONNECT_TIME, &amp;time);

  return rb_float_new(time);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-connect_timeout" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            connect_timeout                             &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the maximum time in seconds that you allow the connection to the
server to take.</p>
          
          

          
          <div class="method-source-code" id="connect_timeout-source">
            <pre>static VALUE ruby_curl_easy_connect_timeout_get(VALUE self, VALUE connect_timeout) {
  CURB_IMMED_GETTER(ruby_curl_easy, connect_timeout, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-connect_timeout-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            connect_timeout = fixnum or nil             &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the maximum time in seconds that you allow the connection to the server
to take. This only limits the connection phase, once it has connected, this
option is of no more use.</p>

<p>Set to nil (or zero) to disable connection timeout (it will then only
timeout on the system&#39;s internal timeouts).</p>
          
          

          
          <div class="method-source-code" id="connect_timeout-3D-source">
            <pre>static VALUE ruby_curl_easy_connect_timeout_set(VALUE self, VALUE connect_timeout) {
  CURB_IMMED_SETTER(ruby_curl_easy, connect_timeout, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-connect_timeout_ms" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            connect_timeout_ms                          &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the maximum time in milliseconds that you allow the connection to
the server to take.</p>
          
          

          
          <div class="method-source-code" id="connect_timeout_ms-source">
            <pre>static VALUE ruby_curl_easy_connect_timeout_ms_get(VALUE self, VALUE connect_timeout_ms) {
  CURB_IMMED_GETTER(ruby_curl_easy, connect_timeout_ms, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-connect_timeout_ms-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            connect_timeout_ms = fixnum or nil          &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the maximum time in milliseconds that you allow the connection to the
server to take. This only limits the connection phase, once it has
connected, this option is of no more use.</p>

<p>Set to nil (or zero) to disable connection timeout (it will then only
timeout on the system&#39;s internal timeouts).</p>
          
          

          
          <div class="method-source-code" id="connect_timeout_ms-3D-source">
            <pre>static VALUE ruby_curl_easy_connect_timeout_ms_set(VALUE self, VALUE connect_timeout_ms) {
  CURB_IMMED_SETTER(ruby_curl_easy, connect_timeout_ms, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-content_type" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            content_type                                &rarr; &quot;content/type&quot; or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the content-type of the downloaded object. This is the value read
from the Content-Type: field. If you get <code>nil</code>, it means that
the server didn&#39;t send a valid Content-Type header or that the protocol
used doesn&#39;t support this.</p>
          
          

          
          <div class="method-source-code" id="content_type-source">
            <pre>static VALUE ruby_curl_easy_content_type_get(VALUE self) {
  ruby_curl_easy *rbce;
  char* type;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_CONTENT_TYPE, &amp;type);

  if (type &amp;&amp; type[0]) {    // curl returns empty string if none
    return rb_str_new2(type);
  } else {
    return Qnil;
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cookiefile" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cookiefile                                  &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the cookiefile file for this <a href="Easy.html">Curl::Easy</a>
instance.</p>
          
          

          
          <div class="method-source-code" id="cookiefile-source">
            <pre>static VALUE ruby_curl_easy_cookiefile_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, cookiefile);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cookiejar" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cookiejar                                   &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the cookiejar file to use for this <a
href="Easy.html">Curl::Easy</a> instance.</p>
          
          

          
          <div class="method-source-code" id="cookiejar-source">
            <pre>static VALUE ruby_curl_easy_cookiejar_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, cookiejar);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cookielist" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cookielist                                &rarr; array
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieves the cookies curl knows in an array of strings. Returned strings
are in Netscape cookiejar format or in Set-Cookie format.</p>

<p>See also option CURLINFO_COOKIELIST of curl_easy_getopt(3) to see how
libcurl behaves.</p>

<p>(requires libcurl 7.14.1 or higher, otherwise -1 is always returned).</p>
          
          

          
          <div class="method-source-code" id="cookielist-source">
            <pre>static VALUE ruby_curl_easy_cookielist_get(VALUE self) {
#ifdef HAVE_CURLINFO_COOKIELIST
  ruby_curl_easy *rbce;
  struct curl_slist *cookies;
  struct curl_slist *cookie;
  VALUE rb_cookies;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_COOKIELIST, &amp;cookies);
  if (!cookies)
    return Qnil;
  rb_cookies = rb_ary_new();
  for (cookie = cookies; cookie; cookie = cookie-&gt;next)
    rb_ary_push(rb_cookies, rb_str_new2(cookie-&gt;data));
  curl_slist_free_all(cookies);
  return rb_cookies;

#else
    rb_warn(&quot;Installed libcurl is too old to support cookielist&quot;);
    return INT2FIX(-1);
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-cookies" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            cookies                                     &rarr; &quot;name1=content1; name2=content2;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the cookies for this <a href="Easy.html">Curl::Easy</a> instance.</p>
          
          

          
          <div class="method-source-code" id="cookies-source">
            <pre>static VALUE ruby_curl_easy_cookies_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, cookies);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dns_cache_timeout" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dns_cache_timeout                           &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the dns cache timeout in seconds.</p>
          
          

          
          <div class="method-source-code" id="dns_cache_timeout-source">
            <pre>static VALUE ruby_curl_easy_dns_cache_timeout_get(VALUE self, VALUE dns_cache_timeout) {
  CURB_IMMED_GETTER(ruby_curl_easy, dns_cache_timeout, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dns_cache_timeout-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            dns_cache_timeout = fixnum or nil           &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the dns cache timeout in seconds. Name resolves will be kept in memory
for this number of seconds. Set to zero (0) to completely disable caching,
or set to nil (or -1) to make the cached entries remain forever. By
default, libcurl caches this info for 60 seconds.</p>
          
          

          
          <div class="method-source-code" id="dns_cache_timeout-3D-source">
            <pre>static VALUE ruby_curl_easy_dns_cache_timeout_set(VALUE self, VALUE dns_cache_timeout) {
  CURB_IMMED_SETTER(ruby_curl_easy, dns_cache_timeout, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-download_speed" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            download_speed                              &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the average download speed that curl measured for the preceeding
complete download.</p>
          
          

          
          <div class="method-source-code" id="download_speed-source">
            <pre>static VALUE ruby_curl_easy_download_speed_get(VALUE self) {
  ruby_curl_easy *rbce;
  double bytes;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_SPEED_DOWNLOAD, &amp;bytes);

  return rb_float_new(bytes);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-downloaded_bytes" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            downloaded_bytes                            &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the total amount of bytes that were downloaded in the preceeding
transfer.</p>
          
          

          
          <div class="method-source-code" id="downloaded_bytes-source">
            <pre>static VALUE ruby_curl_easy_downloaded_bytes_get(VALUE self) {
  ruby_curl_easy *rbce;
  double bytes;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_SIZE_DOWNLOAD, &amp;bytes);

  return rb_float_new(bytes);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-downloaded_content_length" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            downloaded_content_length                   &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the content-length of the download. This is the value read from
the Content-Length: field.</p>
          
          

          
          <div class="method-source-code" id="downloaded_content_length-source">
            <pre>static VALUE ruby_curl_easy_downloaded_content_length_get(VALUE self) {
  ruby_curl_easy *rbce;
  double bytes;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_CONTENT_LENGTH_DOWNLOAD, &amp;bytes);

  return rb_float_new(bytes);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-dup" class="method-detail method-alias">
        
        <div class="method-heading">
          <span class="method-name">dup</span><span
            class="method-args">()</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
        </div>

        

        
        <div class="aliases">
          Alias for: <a href="Easy.html#method-i-clone">clone</a>
        </div>
        
      </div>

    
      <div id="method-i-enable_cookies-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            enable_cookies = boolean                    &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether the libcurl cookie engine is enabled for this <a
href="Easy.html">Curl::Easy</a> instance.</p>
          
          

          
          <div class="method-source-code" id="enable_cookies-3D-source">
            <pre>static VALUE ruby_curl_easy_enable_cookies_set(VALUE self, VALUE enable_cookies)
{
  CURB_BOOLEAN_SETTER(ruby_curl_easy, enable_cookies);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-enable_cookies-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            enable_cookies?                             &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether the libcurl cookie engine is enabled for this <a
href="Easy.html">Curl::Easy</a> instance.</p>
          
          

          
          <div class="method-source-code" id="enable_cookies-3F-source">
            <pre>static VALUE ruby_curl_easy_enable_cookies_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, enable_cookies);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-encoding" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            encoding                                    &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the set encoding types</p>
          
          

          
          <div class="method-source-code" id="encoding-source">
            <pre>static VALUE ruby_curl_easy_encoding_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, encoding);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-encoding-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            encoding = string                           &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the accepted encoding types, curl will handle all of the decompression</p>
          
          

          
          <div class="method-source-code" id="encoding-3D-source">
            <pre>static VALUE ruby_curl_easy_encoding_set(VALUE self, VALUE encoding) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, encoding);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-escape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            escape(&quot;some text&quot;)                         &rarr; &quot;some%20text&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Convert the given input string to a URL encoded string and return the
result. All input characters that are not a-z, A-Z or 0-9 are converted to
their “URL escaped” version (%NN where NN is a two-digit hexadecimal
number).</p>
          
          

          
          <div class="method-source-code" id="escape-source">
            <pre>static VALUE ruby_curl_easy_escape(VALUE self, VALUE svalue) {
  ruby_curl_easy *rbce;
  char *result;
  VALUE rresult;
  VALUE str = svalue;

  Data_Get_Struct(self, ruby_curl_easy, rbce);

  /* NOTE: make sure the value is a string, if not call to_s */
  if( rb_type(str) != T_STRING ) { str = rb_funcall(str,rb_intern(&quot;to_s&quot;),0); }

#if (LIBCURL_VERSION_NUM &gt;= 0x070f04)
  result = (char*)curl_easy_escape(rbce-&gt;curl, StringValuePtr(str), (int)RSTRING_LEN(str));
#else
  result = (char*)curl_escape(StringValuePtr(str), (int)RSTRING_LEN(str));
#endif

  rresult = rb_str_new2(result);
  curl_free(result);

  return rresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fetch_file_time-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            fetch_file_time = boolean                   &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance will fetch
remote file times, if available.</p>
          
          

          
          <div class="method-source-code" id="fetch_file_time-3D-source">
            <pre>static VALUE ruby_curl_easy_fetch_file_time_set(VALUE self, VALUE fetch_file_time) {
  CURB_BOOLEAN_SETTER(ruby_curl_easy, fetch_file_time);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-fetch_file_time-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            fetch_file_time?                            &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance will fetch
remote file times, if available.</p>
          
          

          
          <div class="method-source-code" id="fetch_file_time-3F-source">
            <pre>static VALUE ruby_curl_easy_fetch_file_time_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, fetch_file_time);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-file_time" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            file_time                                   &rarr; fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the remote time of the retrieved document (in number of seconds
since 1 jan 1970 in the GMT/UTC time zone). If you get -1, it can be
because of many reasons (unknown, the server hides it or the server
doesn&#39;t support the command that tells document time etc) and the time
of the document is unknown.</p>

<p>Note that you must tell the server to collect this information before the
transfer is made, by setting <code>fetch_file_time?</code> to true, or you
will unconditionally get a -1 back.</p>

<p>This requires libcurl 7.5 or higher - otherwise -1 is unconditionally
returned.</p>
          
          

          
          <div class="method-source-code" id="file_time-source">
            <pre>static VALUE ruby_curl_easy_file_time_get(VALUE self) {
#ifdef HAVE_CURLINFO_FILETIME
  ruby_curl_easy *rbce;
  long time;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_FILETIME, &amp;time);

  return LONG2NUM(time);
#else
  rb_warn(&quot;Installed libcurl is too old to support file_time&quot;);
  return LONG2NUM(0);
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-follow_location-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            follow_location?                            &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance will follow
Location: headers in HTTP responses.</p>
          
          

          
          <div class="method-source-code" id="follow_location-3F-source">
            <pre>static VALUE ruby_curl_easy_follow_location_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, follow_location);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ftp_commands" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">ftp_commands</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>call-seq</p>

<pre>easy.ftp_commands                                =&gt; array or nil</pre>
          
          

          
          <div class="method-source-code" id="ftp_commands-source">
            <pre>static VALUE ruby_curl_easy_ftp_commands_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, ftp_commands);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ftp_commands-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ftp_commands = [&quot;CWD /&quot;, &quot;MKD directory&quot;]   &rarr; [&quot;CWD /&quot;, ...]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Explicitly sets the list of commands to execute on the FTP server when
calling perform</p>
          
          

          
          <div class="method-source-code" id="ftp_commands-3D-source">
            <pre>static VALUE ruby_curl_easy_ftp_commands_set(VALUE self, VALUE ftp_commands) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, ftp_commands);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ftp_entry_path" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ftp_entry_path                                &rarr; &quot;C:\ftp\root\&quot; or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the path of the entry path. That is the initial path libcurl ended
up in when logging on to the remote FTP server. This returns
<code>nil</code> if something is wrong.</p>

<p>(requires libcurl 7.15.4 or higher, otherwise <code>nil</code> is always
returned).</p>
          
          

          
          <div class="method-source-code" id="ftp_entry_path-source">
            <pre>static VALUE ruby_curl_easy_ftp_entry_path_get(VALUE self) {
#ifdef HAVE_CURLINFO_FTP_ENTRY_PATH
  ruby_curl_easy *rbce;
  char* path = NULL;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_FTP_ENTRY_PATH, &amp;path);

  if (path &amp;&amp; path[0]) {    // curl returns NULL or empty string if none
    return rb_str_new2(path);
  } else {
    return Qnil;
  }
#else
  rb_warn(&quot;Installed libcurl is too old to support num_connects&quot;);
  return Qnil;
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ftp_filemethod" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">ftp_filemethod</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>call-seq</p>

<pre>easy.ftp_filemethod                              =&gt; fixnum</pre>

<p>Get the configuration for how libcurl will reach files on the server.</p>
          
          

          
          <div class="method-source-code" id="ftp_filemethod-source">
            <pre>static VALUE ruby_curl_easy_ftp_filemethod_get(VALUE self, VALUE ftp_filemethod) {
  CURB_IMMED_GETTER(ruby_curl_easy, ftp_filemethod, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ftp_filemethod-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ftp_filemethod = value                      &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Controls how libcurl reaches files on the server. Valid options are
Curl::CURL_MULTICWD, Curl::CURL_NOCWD, and Curl::CURL_SINGLECWD (see
libcurl docs for CURLOPT_FTP_METHOD).</p>
          
          

          
          <div class="method-source-code" id="ftp_filemethod-3D-source">
            <pre>static VALUE ruby_curl_easy_ftp_filemethod_set(VALUE self, VALUE ftp_filemethod) {
  CURB_IMMED_SETTER(ruby_curl_easy, ftp_filemethod, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ftp_response_timeout" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ftp_response_timeout                        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the maximum time that libcurl will wait for FTP command responses.</p>
          
          

          
          <div class="method-source-code" id="ftp_response_timeout-source">
            <pre>static VALUE ruby_curl_easy_ftp_response_timeout_get(VALUE self, VALUE ftp_response_timeout) {
  CURB_IMMED_GETTER(ruby_curl_easy, ftp_response_timeout, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ftp_response_timeout-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ftp_response_timeout = fixnum or nil        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set a timeout period (in seconds) on the amount of time that the server is
allowed to take in order to generate a response message for a command
before the session is considered hung. While curl is waiting for a
response, this value overrides <code>timeout</code>. It is recommended that
if used in conjunction with <code>timeout</code>, you set
<code>ftp_response_timeout</code> to a value smaller than
<code>timeout</code>.</p>

<p>Ignored if libcurl version is &lt; 7.10.8.</p>
          
          

          
          <div class="method-source-code" id="ftp_response_timeout-3D-source">
            <pre>static VALUE ruby_curl_easy_ftp_response_timeout_set(VALUE self, VALUE ftp_response_timeout) {
  CURB_IMMED_SETTER(ruby_curl_easy, ftp_response_timeout, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-getinfo" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            getinfo Fixnum &rarr; value
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Iniital access to libcurl curl_easy_getinfo, remember getinfo doesn&#39;t
return the same values as setopt</p>
          
          

          
          <div class="method-source-code" id="getinfo-source">
            <pre>static VALUE ruby_curl_easy_get_opt(VALUE self, VALUE opt) {
  return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-header_in_body-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            header_in_body = boolean                    &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance will return
HTTP headers combined with body data. If this option is set true, both
header and body data will go to <code>body_str</code> (or the configured
<code>on_body</code> handler).</p>
          
          

          
          <div class="method-source-code" id="header_in_body-3D-source">
            <pre>static VALUE ruby_curl_easy_header_in_body_set(VALUE self, VALUE header_in_body) {
  CURB_BOOLEAN_SETTER(ruby_curl_easy, header_in_body);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-header_in_body-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            header_in_body?                             &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance will return
HTTP headers combined with body data.</p>
          
          

          
          <div class="method-source-code" id="header_in_body-3F-source">
            <pre>static VALUE ruby_curl_easy_header_in_body_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, header_in_body);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-header_size" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            header_size                                 &rarr; fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the total size of all the headers received in the preceeding
transfer.</p>
          
          

          
          <div class="method-source-code" id="header_size-source">
            <pre>static VALUE ruby_curl_easy_header_size_get(VALUE self) {
  ruby_curl_easy *rbce;
  long size;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_HEADER_SIZE, &amp;size);

  return LONG2NUM(size);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-header_str" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            header_str                                  &rarr; &quot;response header&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Return the response header from the previous call to <code>perform</code>.
This is populated by the default <code>on_header</code> handler - if you
supply your own header handler, this string will be empty.</p>
          
          

          
          <div class="method-source-code" id="header_str-source">
            <pre>static VALUE ruby_curl_easy_header_str_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, header_data);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-headers" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            headers                                     &rarr; Hash, Array or Str
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the custom HTTP headers for following requests.</p>
          
          

          
          <div class="method-source-code" id="headers-source">
            <pre>static VALUE ruby_curl_easy_headers_get(VALUE self) {
  ruby_curl_easy *rbce;
  VALUE headers;
  Data_Get_Struct(self, ruby_curl_easy, rbce);
  headers = rb_easy_get(&quot;headers&quot;);//rb_hash_aref(rbce-&gt;opts, rb_intern(&quot;headers&quot;));
  if (headers == Qnil) { headers = rb_easy_set(&quot;headers&quot;, rb_hash_new()); }
  return headers;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-headers-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            headers = &quot;Header: val&quot;                              &rarr; &quot;Header: val&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            headers = {&quot;Header&quot; =&gt; &quot;val&quot; ..., &quot;Header&quot; =&gt; &quot;val&quot;} &rarr; {&quot;Header: val&quot;, ...}
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            headers = [&quot;Header: val&quot; ..., &quot;Header: val&quot;]         &rarr; [&quot;Header: val&quot;, ...]
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set custom HTTP headers for following requests. This can be used to add
custom headers, or override standard headers used by libcurl. It defaults
to a Hash.</p>

<p>For example to set a standard or custom header:</p>

<pre class="ruby"><span class="ruby-identifier">easy</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&quot;MyHeader&quot;</span>] = <span class="ruby-string">&quot;myval&quot;</span>
</pre>

<p>To remove a standard header (this is useful when removing libcurls default
&#39;Expect: 100-Continue&#39; header when using HTTP form posts):</p>

<pre class="ruby"><span class="ruby-identifier">easy</span>.<span class="ruby-identifier">headers</span>[<span class="ruby-string">&quot;Expect&quot;</span>] = <span class="ruby-string">&#39;&#39;</span>
</pre>

<p>Anything passed to libcurl as a header will be converted to a string during
the perform step.</p>
          
          

          
          <div class="method-source-code" id="headers-3D-source">
            <pre>static VALUE ruby_curl_easy_headers_set(VALUE self, VALUE headers) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, headers);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-http" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            http(verb)
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Send an HTTP request with method set to verb, using the current options set
for this <a href="Easy.html">Curl::Easy</a> instance. This method always
returns true or raises an exception (defined under <a
href="Err.html">Curl::Err</a>) on error.</p>
          
          

          
          <div class="method-source-code" id="http-source">
            <pre>static VALUE ruby_curl_easy_perform_verb(VALUE self, VALUE verb) {
  VALUE str_verb;
  if (rb_type(verb) == T_STRING) {
    return ruby_curl_easy_perform_verb_str(self, StringValueCStr(verb));
  }
  else if (rb_respond_to(verb,rb_intern(&quot;to_s&quot;))) {
    str_verb = rb_funcall(verb, rb_intern(&quot;to_s&quot;), 0);
    return ruby_curl_easy_perform_verb_str(self, StringValueCStr(str_verb));
  }
  else {
    rb_raise(rb_eRuntimeError, &quot;Invalid HTTP VERB, must response to &#39;to_s&#39;&quot;);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-http_auth_types" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            http_auth_types                             &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the HTTP authentication types that may be used for the following
<code>perform</code> calls.</p>
          
          

          
          <div class="method-source-code" id="http_auth_types-source">
            <pre>static VALUE ruby_curl_easy_http_auth_types_get(VALUE self) {
  CURB_IMMED_GETTER(ruby_curl_easy, http_auth_types, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-http_auth_types-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            http_auth_types = fixnum or nil             &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            http_auth_types = [:basic,:digest,:digest_ie,:gssnegotiate, :ntlm, :any, :anysafe]
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the HTTP authentication types that may be used for the following
<code>perform</code> calls. This is a bitmap made by ORing together the
Curl::CURLAUTH constants.</p>
          
          

          
          <div class="method-source-code" id="http_auth_types-3D-source">
            <pre>static VALUE ruby_curl_easy_http_auth_types_set(int argc, VALUE *argv, VALUE self) {//VALUE self, VALUE http_auth_types) {
  ruby_curl_easy *rbce;
  VALUE args_ary;
  long i, len;
  char* node = NULL;
  long mask = 0;

  rb_scan_args(argc, argv, &quot;*&quot;, &amp;args_ary);
  Data_Get_Struct(self, ruby_curl_easy, rbce);

  len = RARRAY_LEN(args_ary);

  if (len == 1 &amp;&amp; (rb_ary_entry(args_ary,0) == Qnil || TYPE(rb_ary_entry(args_ary,0)) == T_FIXNUM ||
        TYPE(rb_ary_entry(args_ary,0)) == T_BIGNUM)) {
    if (rb_ary_entry(args_ary,0) == Qnil) {
      rbce-&gt;http_auth_types = 0;
    }
    else {
      rbce-&gt;http_auth_types = NUM2LONG(rb_ary_entry(args_ary,0));
    }
  }
  else {
    // we could have multiple values, but they should be symbols
    node = RSTRING_PTR(rb_funcall(rb_ary_entry(args_ary,0),rb_intern(&quot;to_s&quot;),0));
    mask = CURL_HTTPAUTH_STR_TO_NUM(node);
    for( i = 1; i &lt; len; ++i ) {
      node = RSTRING_PTR(rb_funcall(rb_ary_entry(args_ary,i),rb_intern(&quot;to_s&quot;),0));
      mask |= CURL_HTTPAUTH_STR_TO_NUM(node);
    }
    rbce-&gt;http_auth_types = mask;
  }
  return LONG2NUM(rbce-&gt;http_auth_types);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-http_connect_code" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            http_connect_code                           &rarr; fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the last received proxy response code to a CONNECT request.</p>
          
          

          
          <div class="method-source-code" id="http_connect_code-source">
            <pre>static VALUE ruby_curl_easy_http_connect_code_get(VALUE self) {
  ruby_curl_easy *rbce;
  long code;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_HTTP_CONNECTCODE, &amp;code);

  return LONG2NUM(code);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-http_post" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            http_post(&quot;url=encoded%20form%20data;and=so%20on&quot;) &rarr; true
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            http_post(&quot;url=encoded%20form%20data&quot;, &quot;and=so%20on&quot;, ...) &rarr; true
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            http_post(&quot;url=encoded%20form%20data&quot;, Curl::PostField, &quot;and=so%20on&quot;, ...) &rarr; true
          </span>
          
        </div>
        
        <div class="method-heading">
          <span class="method-callseq">
            http_post(Curl::PostField, Curl::PostField ..., Curl::PostField) &rarr; true
          </span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>POST the specified formdata to the currently configured URL using the
current options set for this <a href="Easy.html">Curl::Easy</a> instance.
This method always returns true, or raises an exception (defined under <a
href="Err.html">Curl::Err</a>) on error.</p>

<p>The Content-type of the POST is determined by the current setting of
multipart_form_post? , according to the following rules:</p>
<ul><li>
<p>When false (the default): the form will be POSTed with a content-type of
&#39;application/x-www-form-urlencoded&#39;, and any of the four calling
forms may be used.</p>
</li><li>
<p>When true: the form will be POSTed with a content-type of
&#39;multipart/formdata&#39;. Only the last calling form may be used, i.e.
only <a href="PostField.html">PostField</a> instances may be POSTed. In
this mode, individual fields&#39; content-types are recognised, and file
upload fields are supported.</p>
</li></ul>
          
          

          
          <div class="method-source-code" id="http_post-source">
            <pre>static VALUE ruby_curl_easy_perform_post(int argc, VALUE *argv, VALUE self) {
  ruby_curl_easy *rbce;
  CURL *curl;
  int i;
  VALUE args_ary;

  rb_scan_args(argc, argv, &quot;*&quot;, &amp;args_ary);

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl = rbce-&gt;curl;

  curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, NULL);

  if (rbce-&gt;multipart_form_post) {
    VALUE ret;
    struct curl_httppost *first = NULL, *last = NULL;

    // Make the multipart form
    for (i = 0; i &lt; argc; i++) {
      if (rb_obj_is_instance_of(argv[i], cCurlPostField)) {
        append_to_form(argv[i], &amp;first, &amp;last);
      } else if (rb_type(argv[i]) == T_ARRAY) {
        // see: https://github.com/rvanlieshout/curb/commit/8bcdefddc0162484681ebd1a92d52a642666a445
        long c = 0, argv_len = RARRAY_LEN(argv[i]);
        for (; c &lt; argv_len; ++c) {
          if (rb_obj_is_instance_of(rb_ary_entry(argv[i],c), cCurlPostField)) {
            append_to_form(rb_ary_entry(argv[i],c), &amp;first, &amp;last);
          } else {
            rb_raise(eCurlErrInvalidPostField, &quot;You must use PostFields only with multipart form posts&quot;);
            return Qnil;
          }
        }
      } else {
        rb_raise(eCurlErrInvalidPostField, &quot;You must use PostFields only with multipart form posts&quot;);
        return Qnil;
      }
    }

    curl_easy_setopt(curl, CURLOPT_POST, 0);
    curl_easy_setopt(curl, CURLOPT_HTTPPOST, first);
    ret = rb_funcall(self, rb_intern(&quot;perform&quot;), 0);
    curl_formfree(first);

    return ret;
  } else {
    VALUE post_body = Qnil;
    /* TODO: check for PostField.file and raise error before to_s fails */
    if ((post_body = rb_funcall(args_ary, idJoin, 1, rbstrAmp)) == Qnil) {
      rb_raise(eCurlErrError, &quot;Failed to join arguments&quot;);
      return Qnil;
    } else {
      /* if the function call above returns an empty string because no additional arguments were passed this makes sure
         a previously set easy.post_body = &quot;arg=foo&amp;bar=bin&quot;  will be honored */
      if( post_body != Qnil &amp;&amp; rb_type(post_body) == T_STRING &amp;&amp; RSTRING_LEN(post_body) &gt; 0 ) {
        ruby_curl_easy_post_body_set(self, post_body);
      }

      /* if post body is not defined, set it so we enable POST header, even though the request body is empty */
      if( rb_easy_nil(&quot;postdata_buffer&quot;) ) {
        ruby_curl_easy_post_body_set(self, post_body);
      }

      return rb_funcall(self, rb_intern(&quot;perform&quot;), 0);
    }
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-http_put" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            http_put(data)                              &rarr; true
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>PUT the supplied data to the currently configured URL using the current
options set for this <a href="Easy.html">Curl::Easy</a> instance. This
method always returns true, or raises an exception (defined under <a
href="Err.html">Curl::Err</a>) on error.</p>
          
          

          
          <div class="method-source-code" id="http_put-source">
            <pre>static VALUE ruby_curl_easy_perform_put(VALUE self, VALUE data) {
  ruby_curl_easy *rbce;
  CURL *curl;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl = rbce-&gt;curl;

  curl_easy_setopt(curl, CURLOPT_CUSTOMREQUEST, NULL);
  ruby_curl_easy_put_data_set(self, data);

  return rb_funcall(self, rb_intern(&quot;perform&quot;), 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ignore_content_length-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ignore_content_length = boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="Easy.html">Curl::Easy</a> instance should
ignore the content length header.</p>
          
          

          
          <div class="method-source-code" id="ignore_content_length-3D-source">
            <pre>static VALUE ruby_curl_easy_ignore_content_length_set(VALUE self, VALUE ignore_content_length)
{
  CURB_BOOLEAN_SETTER(ruby_curl_easy, ignore_content_length);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ignore_content_length-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ignore_content_length?                             &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="Easy.html">Curl::Easy</a> instance ignores
the content length header.</p>
          
          

          
          <div class="method-source-code" id="ignore_content_length-3F-source">
            <pre>static VALUE ruby_curl_easy_ignore_content_length_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, ignore_content_length);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-inspect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            inspect                                     &rarr; &quot;#&lt;Curl::Easy http://google.com/&gt;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="inspect-source">
            <pre>static VALUE ruby_curl_easy_inspect(VALUE self) {
  char buf[64];
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);
  /* if we don&#39;t have a url set... we&#39;ll crash... */
  if( !rb_easy_nil(&quot;url&quot;) &amp;&amp; rb_easy_type_check(&quot;url&quot;, T_STRING)) {
    VALUE url = rb_easy_get(&quot;url&quot;);
    size_t len = 13+((RSTRING_LEN(url) &gt; 50) ? 50 : RSTRING_LEN(url));
    /* &quot;#&lt;Net::HTTP http://www.google.com/:80 open=false&gt;&quot; */
    memcpy(buf,&quot;#&lt;Curl::Easy &quot;, 13);
    memcpy(buf+13,StringValueCStr(url), (len - 13));
    buf[len++] = &#39;&gt;&#39;;
    return rb_str_new(buf,len);
  }
  return rb_str_new2(&quot;#&lt;Curl::Easy&gt;&quot;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-interface" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            interface                                   &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the interface name that is used as the outgoing network interface.
The name can be an interface name, an IP address or a host name.</p>
          
          

          
          <div class="method-source-code" id="interface-source">
            <pre>static VALUE ruby_curl_easy_interface_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, interface_hm);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-last_effective_url" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            last_effective_url                          &rarr; &quot;http://some.url&quot; or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the last effective URL used by this instance. This is the URL used
in the last <code>perform</code> call, and may differ from the value of
easy.url.</p>
          
          

          
          <div class="method-source-code" id="last_effective_url-source">
            <pre>static VALUE ruby_curl_easy_last_effective_url_get(VALUE self) {
  ruby_curl_easy *rbce;
  char* url;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_EFFECTIVE_URL, &amp;url);

  if (url &amp;&amp; url[0]) {    // curl returns empty string if none
    return rb_str_new2(url);
  } else {
    return Qnil;
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-last_result" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            last_result                                    &rarr; 0
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="last_result-source">
            <pre>static VALUE ruby_curl_easy_last_result(VALUE self) {
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);
  return LONG2NUM(rbce-&gt;last_result);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-local_port" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            local_port                                  &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the local port that will be used for the following
<code>perform</code> calls.</p>

<p>This option is ignored if compiled against libcurl &lt; 7.15.2.</p>
          
          

          
          <div class="method-source-code" id="local_port-source">
            <pre>static VALUE ruby_curl_easy_local_port_get(VALUE self) {
  CURB_IMMED_PORT_GETTER(ruby_curl_easy, local_port);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-local_port-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            local_port = fixnum or nil                  &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the local port that will be used for the following <code>perform</code>
calls.</p>

<p>Passing <code>nil</code> will return to the default behaviour (no local
port preference).</p>

<p>This option is ignored if compiled against libcurl &lt; 7.15.2.</p>
          
          

          
          <div class="method-source-code" id="local_port-3D-source">
            <pre>static VALUE ruby_curl_easy_local_port_set(VALUE self, VALUE local_port) {
  CURB_IMMED_PORT_SETTER(ruby_curl_easy, local_port, &quot;port&quot;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-local_port_range" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            local_port_range                            &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the local port range that will be used for the following
<code>perform</code> calls.</p>

<p>This option is ignored if compiled against libcurl &lt; 7.15.2.</p>
          
          

          
          <div class="method-source-code" id="local_port_range-source">
            <pre>static VALUE ruby_curl_easy_local_port_range_get(VALUE self) {
  CURB_IMMED_PORT_GETTER(ruby_curl_easy, local_port_range);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-local_port_range-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            local_port_range = fixnum or nil            &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the local port range that will be used for the following
<code>perform</code> calls. This is a number (between 0 and 65535) that
determines how far libcurl may deviate from the supplied
<code>local_port</code> in order to find an available port.</p>

<p>If you set <code>local_port</code> it&#39;s also recommended that you set
this, since it is fairly likely that your specified port will be
unavailable.</p>

<p>This option is ignored if compiled against libcurl &lt; 7.15.2.</p>
          
          

          
          <div class="method-source-code" id="local_port_range-3D-source">
            <pre>static VALUE ruby_curl_easy_local_port_range_set(VALUE self, VALUE local_port_range) {
  CURB_IMMED_PORT_SETTER(ruby_curl_easy, local_port_range, &quot;port range&quot;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-low_speed_limit" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            low_speed_limit                        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the minimum transfer speed over +low_speed+time+ below which the
transfer will be aborted.</p>
          
          

          
          <div class="method-source-code" id="low_speed_limit-source">
            <pre>static VALUE ruby_curl_easy_low_speed_limit_get(VALUE self, VALUE low_speed_limit) {
  CURB_IMMED_GETTER(ruby_curl_easy, low_speed_limit, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-low_speed_limit-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            low_speed_limit = fixnum or nil        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the transfer speed (in bytes per second) that the transfer should be
below during <code>low_speed_time</code> seconds for the library to
consider it too slow and abort.</p>
          
          

          
          <div class="method-source-code" id="low_speed_limit-3D-source">
            <pre>static VALUE ruby_curl_easy_low_speed_limit_set(VALUE self, VALUE low_speed_limit) {
  CURB_IMMED_SETTER(ruby_curl_easy, low_speed_limit, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-low_speed_time" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            low_speed_time                        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the time that the transfer should be below
<code>low_speed_limit</code> for the library to abort it.</p>
          
          

          
          <div class="method-source-code" id="low_speed_time-source">
            <pre>static VALUE ruby_curl_easy_low_speed_time_get(VALUE self, VALUE low_speed_time) {
  CURB_IMMED_GETTER(ruby_curl_easy, low_speed_time, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-low_speed_time-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            low_speed_time = fixnum or nil        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the time (in seconds) that the transfer should be below the
<code>low_speed_limit</code> for the library to consider it too slow and
abort.</p>
          
          

          
          <div class="method-source-code" id="low_speed_time-3D-source">
            <pre>static VALUE ruby_curl_easy_low_speed_time_set(VALUE self, VALUE low_speed_time) {
  CURB_IMMED_SETTER(ruby_curl_easy, low_speed_time, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max_recv_speed_large" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_recv_speed_large = fixnum or nil        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the maximal receiving transfer speed (in bytes per second)</p>
          
          

          
          <div class="method-source-code" id="max_recv_speed_large-source">
            <pre>static VALUE ruby_curl_easy_max_recv_speed_large_get(VALUE self, VALUE max_recv_speed_large) {
  CURB_IMMED_GETTER(ruby_curl_easy, max_recv_speed_large, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max_recv_speed_large-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_recv_speed_large = fixnum or nil        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the maximal receiving transfer speed (in bytes per second)</p>
          
          

          
          <div class="method-source-code" id="max_recv_speed_large-3D-source">
            <pre>static VALUE ruby_curl_easy_max_recv_speed_large_set(VALUE self, VALUE max_recv_speed_large) {
  CURB_IMMED_SETTER(ruby_curl_easy, max_recv_speed_large, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max_redirects" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_redirects                               &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the maximum number of redirections to follow in the following
<code>perform</code> calls.</p>
          
          

          
          <div class="method-source-code" id="max_redirects-source">
            <pre>static VALUE ruby_curl_easy_max_redirects_get(VALUE self) {
  CURB_IMMED_GETTER(ruby_curl_easy, max_redirs, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max_redirects-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_redirects = fixnum or nil               &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the maximum number of redirections to follow in the following
<code>perform</code> calls. Set to nil or -1 allow an infinite number (the
default). Setting this option only makes sense if
<code>follow_location</code> is also set true.</p>

<p>With libcurl &gt;= 7.15.1, setting this to 0 will cause libcurl to refuse
any redirect.</p>
          
          

          
          <div class="method-source-code" id="max_redirects-3D-source">
            <pre>static VALUE ruby_curl_easy_max_redirects_set(VALUE self, VALUE max_redirs) {
  CURB_IMMED_SETTER(ruby_curl_easy, max_redirs, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max_send_speed_large" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_send_speed_large = fixnum or nil        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the maximal sending transfer speed (in bytes per second)</p>
          
          

          
          <div class="method-source-code" id="max_send_speed_large-source">
            <pre>static VALUE ruby_curl_easy_max_send_speed_large_get(VALUE self, VALUE max_send_speed_large) {
  CURB_IMMED_GETTER(ruby_curl_easy, max_send_speed_large, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-max_send_speed_large-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            max_send_speed_large = fixnum or nil        &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the maximal sending transfer speed (in bytes per second)</p>
          
          

          
          <div class="method-source-code" id="max_send_speed_large-3D-source">
            <pre>static VALUE ruby_curl_easy_max_send_speed_large_set(VALUE self, VALUE max_send_speed_large) {
  CURB_IMMED_SETTER(ruby_curl_easy, max_send_speed_large, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-multi" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            multi                                     &rarr; &quot;#&lt;Curl::Multi&gt;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="multi-source">
            <pre>static VALUE ruby_curl_easy_multi_get(VALUE self) {
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);
  return rbce-&gt;multi;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-multi-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            multi=multi                                    &rarr; &quot;#&lt;Curl::Multi&gt;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="multi-3D-source">
            <pre>static VALUE ruby_curl_easy_multi_set(VALUE self, VALUE multi) {
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);
  rbce-&gt;multi = multi;
  return rbce-&gt;multi;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-multipart_form_post-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            multipart_form_post = boolean               &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance uses
multipart/formdata content type for HTTP POST requests. If this is false
(the default), then the application/x-www-form-urlencoded content type is
used for the form data.</p>

<p>If this is set true, you must pass one or more <a
href="PostField.html">PostField</a> instances to the <a
href="Easy.html#method-i-http_post">#http_post</a> method - no support for
posting multipart forms from a string is provided.</p>
          
          

          
          <div class="method-source-code" id="multipart_form_post-3D-source">
            <pre>static VALUE ruby_curl_easy_multipart_form_post_set(VALUE self, VALUE multipart_form_post)
{
  CURB_BOOLEAN_SETTER(ruby_curl_easy, multipart_form_post);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-multipart_form_post-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            multipart_form_post?                        &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance uses
multipart/formdata content type for HTTP POST requests.</p>
          
          

          
          <div class="method-source-code" id="multipart_form_post-3F-source">
            <pre>static VALUE ruby_curl_easy_multipart_form_post_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, multipart_form_post);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-name_lookup_time" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            name_lookup_time                            &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the time, in seconds, it took from the start until the name
resolving was completed.</p>
          
          

          
          <div class="method-source-code" id="name_lookup_time-source">
            <pre>static VALUE ruby_curl_easy_name_lookup_time_get(VALUE self) {
  ruby_curl_easy *rbce;
  double time;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_NAMELOOKUP_TIME, &amp;time);

  return rb_float_new(time);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-num_connects" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            num_connects                                &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the number of new connections libcurl had to create to achieve the
previous transfer (only the successful connects are counted). Combined with
<code>redirect_count</code> you are able to know how many times libcurl
successfully reused existing connection(s) or not.</p>

<p>See the Connection Options of curl_easy_setopt(3) to see how libcurl tries
to make persistent connections to save time.</p>

<p>(requires libcurl 7.12.3 or higher, otherwise -1 is always returned).</p>
          
          

          
          <div class="method-source-code" id="num_connects-source">
            <pre>static VALUE ruby_curl_easy_num_connects_get(VALUE self) {
#ifdef HAVE_CURLINFO_NUM_CONNECTS
  ruby_curl_easy *rbce;
  long result;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_NUM_CONNECTS, &amp;result);

  return LONG2NUM(result);
#else
  rb_warn(&quot;Installed libcurl is too old to support num_connects&quot;);
  return LONG2NUM(-1);
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_body" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_body { |body_data| ... }                 &rarr; &amp;lt;old handler&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <code>on_body</code> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_body</code> handler is called for each chunk of response body
passed back by libcurl during <code>perform</code>. It should perform any
processing necessary, and return the actual number of bytes handled.
Normally, this will equal the length of the data string, and CURL will
continue processing. If the returned length does not equal the input
length, CURL will abort the processing with a <a
href="Err/AbortedByCallbackError.html">Curl::Err::AbortedByCallbackError</a>.</p>
          
          

          
          <div class="method-source-code" id="on_body-source">
            <pre>static VALUE ruby_curl_easy_on_body_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, body_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_complete" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_complete {|easy| ... }                   &rarr; &amp;lt;old handler&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <code>on_complete</code> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_complete</code> handler is called when the request is
finished.</p>
          
          

          
          <div class="method-source-code" id="on_complete-source">
            <pre>static VALUE ruby_curl_easy_on_complete_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, complete_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_debug" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_debug { |type, data| ... }               &rarr; &amp;lt;old handler&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <code>on_debug</code> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_debug</code> handler, if configured, will receive detailed
information from libcurl during the perform call. This can be useful for
debugging. Setting a debug handler overrides libcurl&#39;s internal
handler, disabling any output from <code>verbose</code>, if set.</p>

<p>The type argument will match one of the Curl::Easy::CURLINFO_XXXX
constants, and specifies the kind of information contained in the data. The
data is passed as a String.</p>
          
          

          
          <div class="method-source-code" id="on_debug-source">
            <pre>static VALUE ruby_curl_easy_on_debug_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, debug_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_failure" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_failure {|easy,code| ... }               &rarr; &amp;lt;old handler&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <code>on_failure</code> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_failure</code> handler is called when the request is finished
with a status of 50x</p>
          
          

          
          <div class="method-source-code" id="on_failure-source">
            <pre>static VALUE ruby_curl_easy_on_failure_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, failure_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_header" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_header { |header_data| ... }             &rarr; &amp;lt;old handler&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <code>on_header</code> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_header</code> handler is called for each chunk of response
header passed back by libcurl during <code>perform</code>. The semantics
are the same as for the block supplied to <code>on_body</code>.</p>
          
          

          
          <div class="method-source-code" id="on_header-source">
            <pre>static VALUE ruby_curl_easy_on_header_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, header_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_missing" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_missing {|easy,code| ... }                &rarr; &amp;lt;old handler;&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <a
href="Easy.html#method-i-on_missing">#on_missing</a> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_missing</code> handler is called when request is finished with
a status of 40x</p>
          
          

          
          <div class="method-source-code" id="on_missing-source">
            <pre>static VALUE ruby_curl_easy_on_missing_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, missing_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_progress" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_progress { |dl_total, dl_now, ul_total, ul_now| ... } &rarr; &amp;lt;old handler&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <code>on_progress</code> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_progress</code> handler is called regularly by libcurl
(approximately once per second) during transfers to allow the application
to receive progress information. There is no guarantee that the reported
progress will change between calls.</p>

<p>The result of the block call determines whether libcurl continues the
transfer. Returning a non-true value (i.e. nil or false) will cause the
transfer to abort, throwing a <a
href="Err/AbortedByCallbackError.html">Curl::Err::AbortedByCallbackError</a>.</p>
          
          

          
          <div class="method-source-code" id="on_progress-source">
            <pre>static VALUE ruby_curl_easy_on_progress_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, progress_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_redirect" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_redirect {|easy,code| ... }                &rarr; &amp;lt;old handler;&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <a
href="Easy.html#method-i-on_redirect">#on_redirect</a> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_redirect</code> handler is called when request is finished
with a status of 30x</p>
          
          

          
          <div class="method-source-code" id="on_redirect-source">
            <pre>static VALUE ruby_curl_easy_on_redirect_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, redirect_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-on_success" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            on_success { |easy| ... }                   &rarr; &amp;lt;old handler&amp;gt;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Assign or remove the <code>on_success</code> handler for this <a
href="Easy.html">Curl::Easy</a> instance. To remove a previously-supplied
handler, call this method with no attached block.</p>

<p>The <code>on_success</code> handler is called when the request is finished
with a status of 20x</p>
          
          

          
          <div class="method-source-code" id="on_success-source">
            <pre>static VALUE ruby_curl_easy_on_success_set(int argc, VALUE *argv, VALUE self) {
  CURB_HANDLER_PROC_HSETTER(ruby_curl_easy, success_proc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-os_errno" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            os_errno                                    &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the errno variable from a connect failure (requires libcurl 7.12.2
or higher, otherwise 0 is always returned).</p>
          
          

          
          <div class="method-source-code" id="os_errno-source">
            <pre>static VALUE ruby_curl_easy_os_errno_get(VALUE self) {
#ifdef HAVE_CURLINFO_OS_ERRNO
  ruby_curl_easy *rbce;
  long result;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_OS_ERRNO, &amp;result);

  return LONG2NUM(result);
#else
  rb_warn(&quot;Installed libcurl is too old to support os_errno&quot;);
  return LONG2NUM(0);
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-password" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            password                                    &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the current password</p>
          
          

          
          <div class="method-source-code" id="password-source">
            <pre>static VALUE ruby_curl_easy_password_get(VALUE self, VALUE password) {
#if HAVE_CURLOPT_PASSWORD
  CURB_OBJECT_HGETTER(ruby_curl_easy, password);
#else
  return Qnil;
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-password-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            password = string                           &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the HTTP Authentication password.</p>
          
          

          
          <div class="method-source-code" id="password-3D-source">
            <pre>static VALUE ruby_curl_easy_password_set(VALUE self, VALUE password) {
#if HAVE_CURLOPT_PASSWORD
  CURB_OBJECT_HSETTER(ruby_curl_easy, password);
#else
  return Qnil;
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-post_body" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            post_body                                  &rarr; string or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the POST body used in this <a href="Easy.html">Curl::Easy</a>
instance.</p>
          
          

          
          <div class="method-source-code" id="post_body-source">
            <pre>static VALUE ruby_curl_easy_post_body_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, postdata_buffer);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-post_body-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            post_body = &quot;some=form%20data&amp;to=send&quot;      &rarr; string or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets the POST body of this <a href="Easy.html">Curl::Easy</a> instance. 
This is expected to be URL encoded; no additional processing or encoding is
done on the string. The content-type header will be set to
application/x-www-form-urlencoded.</p>

<p>This is handy if you want to perform a POST against a <a
href="Multi.html">Curl::Multi</a> instance.</p>
          
          

          
          <div class="method-source-code" id="post_body-3D-source">
            <pre>static VALUE ruby_curl_easy_post_body_set(VALUE self, VALUE post_body) {
  ruby_curl_easy *rbce;
  CURL *curl;

  char *data;
  long len;

  Data_Get_Struct(self, ruby_curl_easy, rbce);

  curl = rbce-&gt;curl;

  if ( post_body == Qnil ) {
    rb_easy_del(&quot;postdata_buffer&quot;);
    curl_easy_setopt(curl, CURLOPT_HTTPGET, 1);

  } else {
    if (rb_type(post_body) == T_STRING) {
      data = StringValuePtr(post_body);
      len = RSTRING_LEN(post_body);
    }
    else if (rb_respond_to(post_body, rb_intern(&quot;to_s&quot;))) {
      VALUE str_body = rb_funcall(post_body, rb_intern(&quot;to_s&quot;), 0);
      data = StringValuePtr(str_body);
      len = RSTRING_LEN(post_body);
    }
    else {
      rb_raise(rb_eRuntimeError, &quot;post data must respond_to .to_s&quot;);
    }

    // Store the string, since it has to hang around for the duration of the
    // request.  See CURLOPT_POSTFIELDS in the libcurl docs.
    //rbce-&gt;postdata_buffer = post_body;
    rb_easy_set(&quot;postdata_buffer&quot;, post_body);

    curl_easy_setopt(curl, CURLOPT_POST, 1);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDS, data);
    curl_easy_setopt(curl, CURLOPT_POSTFIELDSIZE, len);

    return post_body;
  }

  return Qnil;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-pre_transfer_time" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            pre_transfer_time                           &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the time, in seconds, it took from the start until the file
transfer is just about to begin. This includes all pre-transfer commands
and negotiations that are specific to the particular protocol(s) involved.</p>
          
          

          
          <div class="method-source-code" id="pre_transfer_time-source">
            <pre>static VALUE ruby_curl_easy_pre_transfer_time_get(VALUE self) {
  ruby_curl_easy *rbce;
  double time;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_PRETRANSFER_TIME, &amp;time);

  return rb_float_new(time);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-primary_ip" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            primary_ip                                  &rarr; &quot;xx.xx.xx.xx&quot; or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the resolved IP of the most recent connection done with this curl
handle. This string may be  IPv6 if that&#39;s enabled. This feature
requires curl 7.19.x and above</p>
          
          

          
          <div class="method-source-code" id="primary_ip-source">
            <pre>static VALUE ruby_curl_easy_primary_ip_get(VALUE self) {
  ruby_curl_easy *rbce;
  char* ip;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_PRIMARY_IP, &amp;ip);

  if (ip &amp;&amp; ip[0]) {    // curl returns empty string if none
    return rb_str_new2(ip);
  } else {
    return Qnil;
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_auth_types" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_auth_types                            &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the proxy authentication types that may be used for the following
<code>perform</code> calls.</p>
          
          

          
          <div class="method-source-code" id="proxy_auth_types-source">
            <pre>static VALUE ruby_curl_easy_proxy_auth_types_get(VALUE self) {
  CURB_IMMED_GETTER(ruby_curl_easy, proxy_auth_types, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_auth_types-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_auth_types = fixnum or nil            &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the proxy authentication types that may be used for the following
<code>perform</code> calls. This is a bitmap made by ORing together the
Curl::CURLAUTH constants.</p>
          
          

          
          <div class="method-source-code" id="proxy_auth_types-3D-source">
            <pre>static VALUE ruby_curl_easy_proxy_auth_types_set(VALUE self, VALUE proxy_auth_types) {
  CURB_IMMED_SETTER(ruby_curl_easy, proxy_auth_types, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_headers" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_headers                                     &rarr; Hash, Array or Str
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the custom HTTP <a
href="Easy.html#method-i-proxy_headers">#proxy_headers</a> for following
requests.</p>
          
          

          
          <div class="method-source-code" id="proxy_headers-source">
            <pre>static VALUE ruby_curl_easy_proxy_headers_get(VALUE self) {
  ruby_curl_easy *rbce;
  VALUE proxy_headers;
  Data_Get_Struct(self, ruby_curl_easy, rbce);
  proxy_headers = rb_easy_get(&quot;proxy_headers&quot;);//rb_hash_aref(rbce-&gt;opts, rb_intern(&quot;proxy_headers&quot;));
  if (proxy_headers == Qnil) { proxy_headers = rb_easy_set(&quot;proxy_headers&quot;, rb_hash_new()); }
  return proxy_headers;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_headers-3D" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">proxy_headers=</span><span
            class="method-args">(p1)</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          
          
          

          
          <div class="method-source-code" id="proxy_headers-3D-source">
            <pre>static VALUE ruby_curl_easy_proxy_headers_set(VALUE self, VALUE proxy_headers) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, proxy_headers);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_port" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_port                                  &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the proxy port that will be used for the following
<code>perform</code> calls.</p>
          
          

          
          <div class="method-source-code" id="proxy_port-source">
            <pre>static VALUE ruby_curl_easy_proxy_port_get(VALUE self) {
  CURB_IMMED_PORT_GETTER(ruby_curl_easy, proxy_port);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_port-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_port = fixnum or nil                  &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the proxy port that will be used for the following <code>perform</code>
calls.</p>
          
          

          
          <div class="method-source-code" id="proxy_port-3D-source">
            <pre>static VALUE ruby_curl_easy_proxy_port_set(VALUE self, VALUE proxy_port) {
  CURB_IMMED_PORT_SETTER(ruby_curl_easy, proxy_port, &quot;port&quot;);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_tunnel-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_tunnel = boolean                      &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance will use
proxy tunneling.</p>
          
          

          
          <div class="method-source-code" id="proxy_tunnel-3D-source">
            <pre>static VALUE ruby_curl_easy_proxy_tunnel_set(VALUE self, VALUE proxy_tunnel) {
  CURB_BOOLEAN_SETTER(ruby_curl_easy, proxy_tunnel);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_tunnel-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_tunnel?                               &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance will use
proxy tunneling.</p>
          
          

          
          <div class="method-source-code" id="proxy_tunnel-3F-source">
            <pre>static VALUE ruby_curl_easy_proxy_tunnel_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, proxy_tunnel);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_type" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_type                                  &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the proxy type that will be used for the following
<code>perform</code> calls.</p>
          
          

          
          <div class="method-source-code" id="proxy_type-source">
            <pre>static VALUE ruby_curl_easy_proxy_type_get(VALUE self) {
  CURB_IMMED_GETTER(ruby_curl_easy, proxy_type, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_type-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_type = fixnum or nil                  &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the proxy type that will be used for the following <code>perform</code>
calls. This should be one of the Curl::CURLPROXY constants.</p>
          
          

          
          <div class="method-source-code" id="proxy_type-3D-source">
            <pre>static VALUE ruby_curl_easy_proxy_type_set(VALUE self, VALUE proxy_type) {
  CURB_IMMED_SETTER(ruby_curl_easy, proxy_type, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxy_url" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxy_url                                   &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the HTTP Proxy URL that will be used by subsequent calls to
<code>perform</code>.</p>
          
          

          
          <div class="method-source-code" id="proxy_url-source">
            <pre>static VALUE ruby_curl_easy_proxy_url_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, proxy_url);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-proxypwd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            proxypwd                                    &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the username/password string that will be used for proxy connection
during subsequent calls to <code>perform</code>. The supplied string should
have the form “username:password”</p>
          
          

          
          <div class="method-source-code" id="proxypwd-source">
            <pre>static VALUE ruby_curl_easy_proxypwd_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, proxypwd);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-put_data-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            put_data = data                             &rarr; &quot;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Points this <a href="Easy.html">Curl::Easy</a> instance to data to be
uploaded via PUT.  This sets the request to a PUT type request - useful if
you want to PUT via a multi handle.</p>
          
          

          
          <div class="method-source-code" id="put_data-3D-source">
            <pre>static VALUE ruby_curl_easy_put_data_set(VALUE self, VALUE data) {
  ruby_curl_easy *rbce;
  CURL *curl;
  VALUE upload;
  VALUE headers;

  Data_Get_Struct(self, ruby_curl_easy, rbce);

  upload = ruby_curl_upload_new(cCurlUpload);
  ruby_curl_upload_stream_set(upload,data);

  curl = rbce-&gt;curl;
  rb_easy_set(&quot;upload&quot;, upload); /* keep the upload object alive as long as
                                    the easy handle is active or until the upload
                                    is complete or terminated... */

  curl_easy_setopt(curl, CURLOPT_NOBODY, 0);
  curl_easy_setopt(curl, CURLOPT_UPLOAD, 1);
  curl_easy_setopt(curl, CURLOPT_READFUNCTION, (curl_read_callback)read_data_handler);
#if HAVE_CURLOPT_SEEKFUNCTION
  curl_easy_setopt(curl, CURLOPT_SEEKFUNCTION, (curl_seek_callback)seek_data_handler);
#endif
  curl_easy_setopt(curl, CURLOPT_READDATA, rbce);
#if HAVE_CURLOPT_SEEKDATA
  curl_easy_setopt(curl, CURLOPT_SEEKDATA, rbce);
#endif

  /*
   * we need to set specific headers for the PUT to work... so
   * convert the internal headers structure to a HASH if one is set
   */
  if (!rb_easy_nil(&quot;headers&quot;)) {
    if (rb_easy_type_check(&quot;headers&quot;, T_ARRAY) || rb_easy_type_check(&quot;headers&quot;, T_STRING)) {
      rb_raise(rb_eRuntimeError, &quot;Must set headers as a HASH to modify the headers in an PUT request&quot;);
    }
  }

  // exit fast if the payload is empty
  if (NIL_P(data)) { return data; }

  headers = rb_easy_get(&quot;headers&quot;);
  if( headers == Qnil ) {
    headers = rb_hash_new();
  }

  if (rb_respond_to(data, rb_intern(&quot;read&quot;))) {
    VALUE stat = rb_funcall(data, rb_intern(&quot;stat&quot;), 0);
    if( stat &amp;&amp; rb_hash_aref(headers, rb_str_new2(&quot;Content-Length&quot;)) == Qnil) {
      VALUE size;
      if( rb_hash_aref(headers, rb_str_new2(&quot;Expect&quot;)) == Qnil ) {
        rb_hash_aset(headers, rb_str_new2(&quot;Expect&quot;), rb_str_new2(&quot;&quot;));
      }
      size = rb_funcall(stat, rb_intern(&quot;size&quot;), 0);
      curl_easy_setopt(curl, CURLOPT_INFILESIZE, NUM2LONG(size));
    }
    else if( rb_hash_aref(headers, rb_str_new2(&quot;Content-Length&quot;)) == Qnil &amp;&amp; rb_hash_aref(headers, rb_str_new2(&quot;Transfer-Encoding&quot;)) == Qnil ) {
      rb_hash_aset(headers, rb_str_new2(&quot;Transfer-Encoding&quot;), rb_str_new2(&quot;chunked&quot;));
    }
    else if( rb_hash_aref(headers, rb_str_new2(&quot;Content-Length&quot;)) ) {
      VALUE size = rb_funcall(rb_hash_aref(headers, rb_str_new2(&quot;Content-Length&quot;)), rb_intern(&quot;to_i&quot;), 0);
      curl_easy_setopt(curl, CURLOPT_INFILESIZE, NUM2LONG(size));
    }
  }
  else if (rb_respond_to(data, rb_intern(&quot;to_s&quot;))) {
    curl_easy_setopt(curl, CURLOPT_INFILESIZE, RSTRING_LEN(data));
    if( rb_hash_aref(headers, rb_str_new2(&quot;Expect&quot;)) == Qnil ) {
      rb_hash_aset(headers, rb_str_new2(&quot;Expect&quot;), rb_str_new2(&quot;&quot;));
    }
  }
  else {
    rb_raise(rb_eRuntimeError, &quot;PUT data must respond to read or to_s&quot;);
  }
  rb_easy_set(&quot;headers&quot;,headers);

  // if we made it this far, all should be well.
  return data;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-redirect_count" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            redirect_count                            &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the total number of redirections that were actually followed.</p>

<p>Requires libcurl 7.9.7 or higher, otherwise -1 is always returned.</p>
          
          

          
          <div class="method-source-code" id="redirect_count-source">
            <pre>static VALUE ruby_curl_easy_redirect_count_get(VALUE self) {
#ifdef HAVE_CURLINFO_REDIRECT_COUNT
  ruby_curl_easy *rbce;
  long count;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_REDIRECT_COUNT, &amp;count);

  return LONG2NUM(count);
#else
  rb_warn(&quot;Installed libcurl is too old to support redirect_count&quot;);
  return LONG2NUM(-1);
#endif

}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-redirect_time" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            redirect_time                               &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the total time, in seconds, it took for all redirection steps
include name lookup, connect, pretransfer and transfer before final
transaction was started. <code>redirect_time</code> contains the complete
execution time for multiple redirections.</p>

<p>Requires libcurl 7.9.7 or higher, otherwise -1 is always returned.</p>
          
          

          
          <div class="method-source-code" id="redirect_time-source">
            <pre>static VALUE ruby_curl_easy_redirect_time_get(VALUE self) {
#ifdef HAVE_CURLINFO_REDIRECT_TIME
  ruby_curl_easy *rbce;
  double time;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_REDIRECT_TIME, &amp;time);

  return rb_float_new(time);
#else
  rb_warn(&quot;Installed libcurl is too old to support redirect_time&quot;);
  return rb_float_new(-1);
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-redirect_url" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            redirect_url                               &rarr; &quot;http://some.url&quot; or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve  the URL a redirect would take you to if you would enable
CURLOPT_FOLLOWLOCATION.</p>

<p>Requires libcurl 7.18.2 or higher, otherwise -1 is always returned.</p>
          
          

          
          <div class="method-source-code" id="redirect_url-source">
            <pre>static VALUE ruby_curl_easy_redirect_url_get(VALUE self) {
#ifdef HAVE_CURLINFO_REDIRECT_URL
  ruby_curl_easy *rbce;
  char* url;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_REDIRECT_URL, &amp;url);

  if (url &amp;&amp; url[0]) {    // curl returns empty string if none
    return rb_str_new2(url);
  } else {
    return Qnil;
  }
#else
  rb_warn(&quot;Installed libcurl is too old to support redirect_url&quot;);
  return LONG2NUM(-1);
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-request_size" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            request_size                                &rarr; fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the total size of the issued requests. This is so far only for
HTTP requests. Note that this may be more than one request if
<code>follow_location?</code> is true.</p>
          
          

          
          <div class="method-source-code" id="request_size-source">
            <pre>static VALUE ruby_curl_easy_request_size_get(VALUE self) {
  ruby_curl_easy *rbce;
  long size;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_REQUEST_SIZE, &amp;size);

  return LONG2NUM(size);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-reset" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            reset                                      &rarr; Hash
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Reset the <a href="Easy.html">Curl::Easy</a> instance, clears out all
settings.</p>

<p>from <a
href="http://curl.haxx.se/libcurl/c/curl_easy_reset.html">curl.haxx.se/libcurl/c/curl_easy_reset.html</a>
Re-initializes all options previously set on a specified CURL handle to the
default values. This puts back the handle to the same state as it was in
when it was just created with curl_easy_init(3). It does not change the
following information kept in the handle: live connections, the Session ID
cache, the DNS cache, the cookies and shares.</p>

<p>The return value contains all settings stored.</p>
          
          

          
          <div class="method-source-code" id="reset-source">
            <pre>static VALUE ruby_curl_easy_reset(VALUE self) {
  CURLcode ecode;
  ruby_curl_easy *rbce;
  VALUE opts_dup;
  Data_Get_Struct(self, ruby_curl_easy, rbce);

  if (rbce-&gt;callback_active) {
    rb_raise(rb_eRuntimeError, &quot;Cannot close an active curl handle within a callback&quot;);
  }

  opts_dup = rb_funcall(rbce-&gt;opts, rb_intern(&quot;dup&quot;), 0);

  curl_easy_reset(rbce-&gt;curl);
  ruby_curl_easy_zero(rbce);

  /* rest clobbers the private setting, so reset it to self */
  ecode = curl_easy_setopt(rbce-&gt;curl, CURLOPT_PRIVATE, (void*)self);
  if (ecode != CURLE_OK) {
    raise_curl_easy_error_exception(ecode);
  }

  /* Free everything up */
  if (rbce-&gt;curl_headers) {
    curl_slist_free_all(rbce-&gt;curl_headers);
    rbce-&gt;curl_headers = NULL;
  }

  /* Free everything up */
  if (rbce-&gt;curl_proxy_headers) {
    curl_slist_free_all(rbce-&gt;curl_proxy_headers);
    rbce-&gt;curl_proxy_headers = NULL;
  }

  return opts_dup;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-resolve" class="method-detail ">
        
        <div class="method-heading">
          <span class="method-name">resolve</span><span
            class="method-args">()</span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        

        <div class="method-description">
          
          <p>call-seq</p>

<pre>easy.resolve                                =&gt; array or nil</pre>
          
          

          
          <div class="method-source-code" id="resolve-source">
            <pre>static VALUE ruby_curl_easy_resolve_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, resolve);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-resolve-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            resolve = [ &quot;example.com:80:127.0.0.1&quot; ]   &rarr; [ &quot;example.com:80:127.0.0.1&quot; ]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the resolve list to statically resolve hostnames to IP addresses,
bypassing DNS for matching hostname/port combinations.</p>
          
          

          
          <div class="method-source-code" id="resolve-3D-source">
            <pre>static VALUE ruby_curl_easy_resolve_set(VALUE self, VALUE resolve) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, resolve);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-resolve_mode" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            resolve_mode                                      &rarr; symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determines what type of IP address this <a href="Easy.html">Curl::Easy</a>
instance resolves DNS names to.</p>
          
          

          
          <div class="method-source-code" id="resolve_mode-source">
            <pre>static VALUE ruby_curl_easy_resolve_mode(VALUE self) {
  ruby_curl_easy *rbce;
  unsigned short rm;
  Data_Get_Struct(self, ruby_curl_easy, rbce);

  rm = rbce-&gt;resolve_mode;

  switch(rm) {
    case CURL_IPRESOLVE_V4:
      return rb_easy_sym(&quot;ipv4&quot;);
    case CURL_IPRESOLVE_V6:
      return rb_easy_sym(&quot;ipv6&quot;);
    default:
      return rb_easy_sym(&quot;auto&quot;);
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-resolve_mode-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            resolve_mode = symbol                             &rarr; symbol
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configures what type of IP address this <a href="Easy.html">Curl::Easy</a>
instance resolves DNS names to. Valid options are:</p>
<dl class="rdoc-list label-list"><dt>:auto
<dd>
<p>resolves DNS names to all IP versions your system allows</p>
</dd><dt>:ipv4
<dd>
<p>resolves DNS names to IPv4 only</p>
</dd><dt>:ipv6
<dd>
<p>resolves DNS names to IPv6 only</p>
</dd></dl>
          
          

          
          <div class="method-source-code" id="resolve_mode-3D-source">
            <pre>static VALUE ruby_curl_easy_resolve_mode_set(VALUE self, VALUE resolve_mode) {
  if (TYPE(resolve_mode) != T_SYMBOL) {
    rb_raise(rb_eTypeError, &quot;Must pass a symbol&quot;);
    return Qnil;
  } else {
    ruby_curl_easy *rbce;
    ID resolve_mode_id;
    Data_Get_Struct(self, ruby_curl_easy, rbce);

    resolve_mode_id = rb_to_id(resolve_mode);

    if (resolve_mode_id == rb_intern(&quot;auto&quot;)) {
      rbce-&gt;resolve_mode = CURL_IPRESOLVE_WHATEVER;
      return resolve_mode;
    } else if (resolve_mode_id == rb_intern(&quot;ipv4&quot;)) {
      rbce-&gt;resolve_mode = CURL_IPRESOLVE_V4;
      return resolve_mode;
    } else if (resolve_mode_id == rb_intern(&quot;ipv6&quot;)) {
      rbce-&gt;resolve_mode = CURL_IPRESOLVE_V6;
      return resolve_mode;
    } else {
      rb_raise(rb_eArgError, &quot;Must set to one of :auto, :ipv4, :ipv6&quot;);
      return Qnil;
    }
  }
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-response_code" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            response_code                               &rarr; fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the last received HTTP or FTP code. This will be zero if no server
response code has been received. Note that a proxy&#39;s CONNECT response
should be read with <code>http_connect_code</code> and not this method.</p>
          
          

          
          <div class="method-source-code" id="response_code-source">
            <pre>static VALUE ruby_curl_easy_response_code_get(VALUE self) {
  ruby_curl_easy *rbce;
  long code;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
#ifdef HAVE_CURLINFO_RESPONSE_CODE
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_RESPONSE_CODE, &amp;code);
#else
  // old libcurl
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_HTTP_CODE, &amp;code);
#endif

  return LONG2NUM(code);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-setopt" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            setopt Fixnum, value  &rarr; value
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Initial access to libcurl curl_easy_setopt</p>
          
          

          
          <div class="method-source-code" id="setopt-source">
            <pre>static VALUE ruby_curl_easy_set_opt(VALUE self, VALUE opt, VALUE val) {
  ruby_curl_easy *rbce;
  long option = NUM2LONG(opt);

  Data_Get_Struct(self, ruby_curl_easy, rbce);

  switch (option) {
  /* BEHAVIOR OPTIONS */
  case CURLOPT_VERBOSE: {
    VALUE verbose = val;
    CURB_BOOLEAN_SETTER(ruby_curl_easy, verbose);
    } break;
  case CURLOPT_FOLLOWLOCATION: {
    VALUE follow_location = val;
    CURB_BOOLEAN_SETTER(ruby_curl_easy, follow_location);
    } break;
  /* TODO: CALLBACK OPTIONS */
  /* TODO: ERROR OPTIONS */
  /* NETWORK OPTIONS */
  case CURLOPT_URL: {
    VALUE url = val;
    CURB_OBJECT_HSETTER(ruby_curl_easy, url);
    } break;
  case CURLOPT_CUSTOMREQUEST:
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_CUSTOMREQUEST, NIL_P(val) ? NULL : StringValueCStr(val));
    break;
  case CURLOPT_HTTP_VERSION:
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_HTTP_VERSION, NUM2LONG(val));
    break;
  case CURLOPT_PROXY: {
    VALUE proxy_url = val;
    CURB_OBJECT_HSETTER(ruby_curl_easy, proxy_url);
    } break;
  case CURLOPT_INTERFACE: {
    VALUE interface_hm = val;
    CURB_OBJECT_HSETTER(ruby_curl_easy, interface_hm);
    } break;
  case CURLOPT_HEADER:
  case CURLOPT_NOPROGRESS:
  case CURLOPT_NOSIGNAL:
#if HAVE_CURLOPT_PATH_AS_IS
  case CURLOPT_PATH_AS_IS:
#endif
#if HAVE_CURLOPT_PIPEWAIT
  case CURLOPT_PIPEWAIT:
#endif
  case CURLOPT_HTTPGET:
  case CURLOPT_NOBODY: {
    int type = rb_type(val);
    VALUE value;
    if (type == T_TRUE) {
      value = rb_int_new(1);
    } else if (type == T_FALSE) {
      value = rb_int_new(0);
    } else {
      value = rb_funcall(val, rb_intern(&quot;to_i&quot;), 0);
    }
    curl_easy_setopt(rbce-&gt;curl, option, NUM2LONG(value));
    } break;
  case CURLOPT_POST: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_POST, rb_type(val) == T_TRUE);
  } break;
  case CURLOPT_MAXCONNECTS: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_MAXCONNECTS, NUM2LONG(val));
  } break;
  case CURLOPT_POSTFIELDS: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_POSTFIELDS, NIL_P(val) ? NULL : StringValueCStr(val));
  } break;
  case CURLOPT_USERPWD: {
    VALUE userpwd = val;
    CURB_OBJECT_HSETTER(ruby_curl_easy, userpwd);
    } break;
  case CURLOPT_PROXYUSERPWD: {
    VALUE proxypwd = val;
    CURB_OBJECT_HSETTER(ruby_curl_easy, proxypwd);
    } break;
  case CURLOPT_COOKIE: {
    VALUE cookies = val;
    CURB_OBJECT_HSETTER(ruby_curl_easy, cookies);
    } break;
  case CURLOPT_COOKIEFILE: {
    VALUE cookiefile = val;
    CURB_OBJECT_HSETTER(ruby_curl_easy, cookiefile);
    } break;
  case CURLOPT_COOKIEJAR: {
    VALUE cookiejar = val;
    CURB_OBJECT_HSETTER(ruby_curl_easy, cookiejar);
    } break;
  case CURLOPT_TCP_NODELAY: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_TCP_NODELAY, NUM2LONG(val));
    } break;
  case CURLOPT_RESUME_FROM: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_RESUME_FROM, NUM2LONG(val));
    } break;
  case CURLOPT_FAILONERROR: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_FAILONERROR, NUM2LONG(val));
    } break;
  case CURLOPT_SSL_CIPHER_LIST: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_SSL_CIPHER_LIST, StringValueCStr(val));
    } break;
  case CURLOPT_FORBID_REUSE: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_FORBID_REUSE, NUM2LONG(val));
    } break;
#if HAVE_CURLOPT_GSSAPI_DELEGATION
  case CURLOPT_GSSAPI_DELEGATION: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_GSSAPI_DELEGATION, NUM2LONG(val));
    } break;
#endif
#if HAVE_CURLOPT_UNIX_SOCKET_PATH
  case CURLOPT_UNIX_SOCKET_PATH: {
        curl_easy_setopt(rbce-&gt;curl, CURLOPT_UNIX_SOCKET_PATH, StringValueCStr(val));
    } break;
#endif
#if HAVE_CURLOPT_MAX_SEND_SPEED_LARGE
  case CURLOPT_MAX_SEND_SPEED_LARGE: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_MAX_SEND_SPEED_LARGE, (curl_off_t) NUM2LL(val));
    } break;
#endif
#if HAVE_CURLOPT_MAX_RECV_SPEED_LARGE
  case CURLOPT_MAX_RECV_SPEED_LARGE: {
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_MAX_RECV_SPEED_LARGE, (curl_off_t) NUM2LL(val));
    } break;
#endif
#if HAVE_CURLOPT_MAXFILESIZE
  case CURLOPT_MAXFILESIZE:
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_MAXFILESIZE, NUM2LONG(val));
    break;
#endif
#if HAVE_CURLOPT_TCP_KEEPALIVE
  case CURLOPT_TCP_KEEPALIVE:
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_TCP_KEEPALIVE, NUM2LONG(val));
    break;
  case CURLOPT_TCP_KEEPIDLE:
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_TCP_KEEPIDLE, NUM2LONG(val));
    break;
  case CURLOPT_TCP_KEEPINTVL:
    curl_easy_setopt(rbce-&gt;curl, CURLOPT_TCP_KEEPINTVL, NUM2LONG(val));
    break;
#endif
#if HAVE_CURLOPT_HAPROXYPROTOCOL
  case CURLOPT_HAPROXYPROTOCOL:
    curl_easy_setopt(rbce-&gt;curl, HAVE_CURLOPT_HAPROXYPROTOCOL, NUM2LONG(val));
    break;
#endif
  default:
    rb_raise(rb_eTypeError, &quot;Curb unsupported option&quot;);
  }

  return val;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_verify_host" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_verify_host                            &rarr; number
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance will verify
that the server cert is for the server it is known as.</p>
          
          

          
          <div class="method-source-code" id="ssl_verify_host-source">
            <pre>static VALUE ruby_curl_easy_ssl_verify_host_get(VALUE self) {
  CURB_IMMED_GETTER(ruby_curl_easy, ssl_verify_host, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_verify_host_integer-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_verify_host = [0, 1, 2]                   &rarr; [0, 1, 2]
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance will verify
that the server cert is for the server it is known as. When true (the
default) the server certificate must indicate that the server is the server
to which you meant to connect, or the connection fails. When false, the
connection will succeed regardless of the names in the certificate.</p>

<p>this option controls is of the identity that the server claims. The server
could be lying. To control lying, see ssl_verify_peer? .</p>
          
          

          
          <div class="method-source-code" id="ssl_verify_host_integer-3D-source">
            <pre>static VALUE ruby_curl_easy_ssl_verify_host_set(VALUE self, VALUE ssl_verify_host) {
  CURB_IMMED_SETTER(ruby_curl_easy, ssl_verify_host, 0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_verify_peer-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_verify_peer = boolean                   &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance will verify
the SSL peer certificate. When true (the default), and the verification
fails to prove that the certificate is authentic, the connection fails.
When false, the connection succeeds regardless.</p>

<p>Authenticating the certificate is not by itself very useful. You typically
want to ensure that the server, as authentically identified by its
certificate, is the server you mean to be talking to. The <a
href="Easy.html#method-i-ssl_verify_host">#ssl_verify_host</a>? options
controls that.</p>
          
          

          
          <div class="method-source-code" id="ssl_verify_peer-3D-source">
            <pre>static VALUE ruby_curl_easy_ssl_verify_peer_set(VALUE self, VALUE ssl_verify_peer) {
  CURB_BOOLEAN_SETTER(ruby_curl_easy, ssl_verify_peer);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_verify_peer-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_verify_peer?                            &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance will verify
the SSL peer certificate.</p>
          
          

          
          <div class="method-source-code" id="ssl_verify_peer-3F-source">
            <pre>static VALUE ruby_curl_easy_ssl_verify_peer_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, ssl_verify_peer);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_verify_result" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_verify_result                           &rarr; integer
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the result of the certification verification that was requested
(by setting <code>ssl_verify_peer?</code> to <code>true</code>).</p>
          
          

          
          <div class="method-source-code" id="ssl_verify_result-source">
            <pre>static VALUE ruby_curl_easy_ssl_verify_result_get(VALUE self) {
  ruby_curl_easy *rbce;
  long result;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_SSL_VERIFYRESULT, &amp;result);

  return LONG2NUM(result);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_version" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_version                                 &rarr; fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the version of SSL/TLS that libcurl will attempt to use.</p>
          
          

          
          <div class="method-source-code" id="ssl_version-source">
            <pre>static VALUE ruby_curl_easy_ssl_version_get(VALUE self, VALUE ssl_version) {
  CURB_IMMED_GETTER(ruby_curl_easy, ssl_version, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-ssl_version-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            ssl_version = value                         &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Sets the version of SSL/TLS that libcurl will attempt to use. Valid options
are:</p>

<pre class="ruby"><span class="ruby-constant">Curl</span><span class="ruby-operator">::</span><span class="ruby-constant">CURL_SSLVERSION_DEFAULT</span>
<span class="ruby-constant">Curl</span><span class="ruby-operator">::</span><span class="ruby-constant">CURL_SSLVERSION_TLSv1</span> (<span class="ruby-constant">TLS</span> <span class="ruby-value">1</span>.<span class="ruby-identifier">x</span>)
<span class="ruby-constant">Curl</span><span class="ruby-operator">::</span><span class="ruby-constant">CURL_SSLVERSION_SSLv2</span>
<span class="ruby-constant">Curl</span><span class="ruby-operator">::</span><span class="ruby-constant">CURL_SSLVERSION_SSLv3</span>
<span class="ruby-constant">Curl</span><span class="ruby-operator">::</span><span class="ruby-constant">CURL_SSLVERSION_TLSv1_0</span>
<span class="ruby-constant">Curl</span><span class="ruby-operator">::</span><span class="ruby-constant">CURL_SSLVERSION_TLSv1_1</span>
<span class="ruby-constant">Curl</span><span class="ruby-operator">::</span><span class="ruby-constant">CURL_SSLVERSION_TLSv1_2</span>
</pre>
          
          

          
          <div class="method-source-code" id="ssl_version-3D-source">
            <pre>static VALUE ruby_curl_easy_ssl_version_set(VALUE self, VALUE ssl_version) {
  CURB_IMMED_SETTER(ruby_curl_easy, ssl_version, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-start_transfer_time" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            start_transfer_time                         &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the time, in seconds, it took from the start until the first byte
is just about to be transferred. This includes the
<code>pre_transfer_time</code> and also the time the server needs to
calculate the result.</p>
          
          

          
          <div class="method-source-code" id="start_transfer_time-source">
            <pre>static VALUE ruby_curl_easy_start_transfer_time_get(VALUE self) {
  ruby_curl_easy *rbce;
  double time;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_STARTTRANSFER_TIME, &amp;time);

  return rb_float_new(time);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-timeout" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            timeout                                     &rarr; numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the maximum time in seconds that you allow the libcurl transfer
operation to take.</p>

<p>Uses <a href="Easy.html#method-i-timeout_ms">#timeout_ms</a> internally
instead of timeout.</p>
          
          

          
          <div class="method-source-code" id="timeout-source">
            <pre>static VALUE ruby_curl_easy_timeout_get(VALUE self) {
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);
  return DBL2NUM(rbce-&gt;timeout_ms / 1000.0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-timeout-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            timeout = float, fixnum or nil              &rarr; numeric
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the maximum time in seconds that you allow the libcurl transfer
operation to take. Normally, name lookups can take a considerable time and
limiting operations to less than a few minutes risk aborting perfectly
normal operations.</p>

<p>Set to nil (or zero) to disable timeout (it will then only timeout on the
system&#39;s internal timeouts).</p>

<p>Uses <a href="Easy.html#method-i-timeout_ms">#timeout_ms</a> internally
instead of timeout because it allows for better precision and libcurl will
use the last set value when both timeout and <a
href="Easy.html#method-i-timeout_ms">#timeout_ms</a> are set.</p>
          
          

          
          <div class="method-source-code" id="timeout-3D-source">
            <pre>static VALUE ruby_curl_easy_timeout_set(VALUE self, VALUE timeout_s) {
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);

  if (Qnil == timeout_s || NUM2DBL(timeout_s) &lt;= 0.0) {
    rbce-&gt;timeout_ms = 0;
  } else {
    rbce-&gt;timeout_ms = (unsigned long)(NUM2DBL(timeout_s) * 1000);
  }

  return DBL2NUM(rbce-&gt;timeout_ms / 1000.0);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-timeout_ms" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            timeout_ms                                  &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the maximum time in milliseconds that you allow the libcurl transfer
operation to take.</p>
          
          

          
          <div class="method-source-code" id="timeout_ms-source">
            <pre>static VALUE ruby_curl_easy_timeout_ms_get(VALUE self) {
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);
  return LONG2NUM(rbce-&gt;timeout_ms);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-timeout_ms-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            timeout_ms = fixnum or nil                  &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the maximum time in milliseconds that you allow the libcurl transfer
operation to take. Normally, name lookups can take a considerable time and
limiting operations to less than a few minutes risk aborting perfectly
normal operations.</p>

<p>Set to nil (or zero) to disable timeout (it will then only timeout on the
system&#39;s internal timeouts).</p>
          
          

          
          <div class="method-source-code" id="timeout_ms-3D-source">
            <pre>static VALUE ruby_curl_easy_timeout_ms_set(VALUE self, VALUE timeout_ms) {
  ruby_curl_easy *rbce;
  Data_Get_Struct(self, ruby_curl_easy, rbce);

  if (Qnil == timeout_ms || NUM2DBL(timeout_ms) &lt;= 0.0) {
    rbce-&gt;timeout_ms = 0;
  } else {
    rbce-&gt;timeout_ms = NUM2ULONG(timeout_ms);
  }

  return ULONG2NUM(rbce-&gt;timeout_ms);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-total_time" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            total_time                                  &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the total time in seconds for the previous transfer, including
name resolving, TCP connect etc.</p>
          
          

          
          <div class="method-source-code" id="total_time-source">
            <pre>static VALUE ruby_curl_easy_total_time_get(VALUE self) {
  ruby_curl_easy *rbce;
  double time;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_TOTAL_TIME, &amp;time);

  return rb_float_new(time);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-unescape" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            unescape(&quot;some%20text&quot;)                     &rarr; &quot;some text&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Convert the given URL encoded input string to a “plain string” and return
the result. All input characters that are URL encoded (%XX where XX is a
two-digit hexadecimal number) are converted to their binary versions.</p>
          
          

          
          <div class="method-source-code" id="unescape-source">
            <pre>static VALUE ruby_curl_easy_unescape(VALUE self, VALUE str) {
  ruby_curl_easy *rbce;
  int rlen;
  char *result;
  VALUE rresult;

  Data_Get_Struct(self, ruby_curl_easy, rbce);

#if (LIBCURL_VERSION_NUM &gt;= 0x070f04)
  result = (char*)curl_easy_unescape(rbce-&gt;curl, StringValuePtr(str), (int)RSTRING_LEN(str), &amp;rlen);
#else
  result = (char*)curl_unescape(StringValuePtr(str), (int)RSTRING_LEN(str));
  rlen = strlen(result);
#endif

  rresult = rb_str_new(result, rlen);
  curl_free(result);

  return rresult;
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-unrestricted_auth-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            unrestricted_auth = boolean                 &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance may use any
HTTP authentication method available when necessary.</p>
          
          

          
          <div class="method-source-code" id="unrestricted_auth-3D-source">
            <pre>static VALUE ruby_curl_easy_unrestricted_auth_set(VALUE self, VALUE unrestricted_auth) {
  CURB_BOOLEAN_SETTER(ruby_curl_easy, unrestricted_auth);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-unrestricted_auth-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            unrestricted_auth?                          &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance may use any
HTTP authentication method available when necessary.</p>
          
          

          
          <div class="method-source-code" id="unrestricted_auth-3F-source">
            <pre>static VALUE ruby_curl_easy_unrestricted_auth_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, unrestricted_auth);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-upload_speed" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            upload_speed                                &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the average upload speed that curl measured for the preceeding
complete upload.</p>
          
          

          
          <div class="method-source-code" id="upload_speed-source">
            <pre>static VALUE ruby_curl_easy_upload_speed_get(VALUE self) {
  ruby_curl_easy *rbce;
  double bytes;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_SPEED_UPLOAD, &amp;bytes);

  return rb_float_new(bytes);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-uploaded_bytes" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            uploaded_bytes                              &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the total amount of bytes that were uploaded in the preceeding
transfer.</p>
          
          

          
          <div class="method-source-code" id="uploaded_bytes-source">
            <pre>static VALUE ruby_curl_easy_uploaded_bytes_get(VALUE self) {
  ruby_curl_easy *rbce;
  double bytes;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_SIZE_UPLOAD, &amp;bytes);

  return rb_float_new(bytes);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-uploaded_content_length" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            uploaded_content_length                     &rarr; float
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Retrieve the content-length of the upload.</p>
          
          

          
          <div class="method-source-code" id="uploaded_content_length-source">
            <pre>static VALUE ruby_curl_easy_uploaded_content_length_get(VALUE self) {
  ruby_curl_easy *rbce;
  double bytes;

  Data_Get_Struct(self, ruby_curl_easy, rbce);
  curl_easy_getinfo(rbce-&gt;curl, CURLINFO_CONTENT_LENGTH_UPLOAD, &amp;bytes);

  return rb_float_new(bytes);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-url" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            url                                         &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the URL that will be used by subsequent calls to
<code>perform</code>.</p>
          
          

          
          <div class="method-source-code" id="url-source">
            <pre>static VALUE ruby_curl_easy_url_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, url);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-use_netrc-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            use_netrc = boolean                         &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance will use
data from the user&#39;s .netrc file for FTP connections.</p>
          
          

          
          <div class="method-source-code" id="use_netrc-3D-source">
            <pre>static VALUE ruby_curl_easy_use_netrc_set(VALUE self, VALUE use_netrc) {
  CURB_BOOLEAN_SETTER(ruby_curl_easy, use_netrc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-use_netrc-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            use_netrc?                                  &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance will use
data from the user&#39;s .netrc file for FTP connections.</p>
          
          

          
          <div class="method-source-code" id="use_netrc-3F-source">
            <pre>static VALUE ruby_curl_easy_use_netrc_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, use_netrc);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-use_ssl" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            use_ssl                                     &rarr; fixnum
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the desired level for using SSL on FTP connections.</p>
          
          

          
          <div class="method-source-code" id="use_ssl-source">
            <pre>static VALUE ruby_curl_easy_use_ssl_get(VALUE self, VALUE use_ssl) {
  CURB_IMMED_GETTER(ruby_curl_easy, use_ssl, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-use_ssl-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            use_ssl = value                             &rarr; fixnum or nil
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Ensure libcurl uses SSL for FTP connections. Valid options are
Curl::CURL_USESSL_NONE, Curl::CURL_USESSL_TRY, Curl::CURL_USESSL_CONTROL,
and Curl::CURL_USESSL_ALL.</p>
          
          

          
          <div class="method-source-code" id="use_ssl-3D-source">
            <pre>static VALUE ruby_curl_easy_use_ssl_set(VALUE self, VALUE use_ssl) {
  CURB_IMMED_SETTER(ruby_curl_easy, use_ssl, -1);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-useragent" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            useragent                                  &rarr; &quot;Ruby/Curb&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the user agent string used for this <a
href="Easy.html">Curl::Easy</a> instance</p>
          
          

          
          <div class="method-source-code" id="useragent-source">
            <pre>static VALUE ruby_curl_easy_useragent_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, useragent);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-useragent-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            useragent = &quot;Ruby/Curb&quot;                     &rarr; &quot;&quot;
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the user agent string for this <a href="Easy.html">Curl::Easy</a>
instance</p>
          
          

          
          <div class="method-source-code" id="useragent-3D-source">
            <pre>static VALUE ruby_curl_easy_useragent_set(VALUE self, VALUE useragent) {
  CURB_OBJECT_HSETTER(ruby_curl_easy, useragent);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-username" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            username                                    &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Get the current username</p>
          
          

          
          <div class="method-source-code" id="username-source">
            <pre>static VALUE ruby_curl_easy_username_get(VALUE self, VALUE username) {
#if HAVE_CURLOPT_USERNAME
  CURB_OBJECT_HGETTER(ruby_curl_easy, username);
#else
  return Qnil;
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-username-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            username = string                           &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Set the HTTP Authentication username.</p>
          
          

          
          <div class="method-source-code" id="username-3D-source">
            <pre>static VALUE ruby_curl_easy_username_set(VALUE self, VALUE username) {
#if HAVE_CURLOPT_USERNAME
  CURB_OBJECT_HSETTER(ruby_curl_easy, username);
#else
  return Qnil;
#endif
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-userpwd" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            userpwd                                     &rarr; string
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Obtain the username/password string that will be used for subsequent calls
to <code>perform</code>.</p>
          
          

          
          <div class="method-source-code" id="userpwd-source">
            <pre>static VALUE ruby_curl_easy_userpwd_get(VALUE self) {
  CURB_OBJECT_HGETTER(ruby_curl_easy, userpwd);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-verbose-3D" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            verbose = boolean                           &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Configure whether this <a href="../Curl.html">Curl</a> instance gives
verbose output to STDERR during transfers. Ignored if this instance has an
<a href="Easy.html#method-i-on_debug">#on_debug</a> handler.</p>
          
          

          
          <div class="method-source-code" id="verbose-3D-source">
            <pre>static VALUE ruby_curl_easy_verbose_set(VALUE self, VALUE verbose) {
  CURB_BOOLEAN_SETTER(ruby_curl_easy, verbose);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
      <div id="method-i-verbose-3F" class="method-detail ">
        
        
        <div class="method-heading">
          <span class="method-callseq">
            verbose?                                    &rarr; boolean
          </span>
          
          <span class="method-click-advice">click to toggle source</span>
          
        </div>
        
        

        <div class="method-description">
          
          <p>Determine whether this <a href="../Curl.html">Curl</a> instance gives
verbose output to STDERR during transfers.</p>
          
          

          
          <div class="method-source-code" id="verbose-3F-source">
            <pre>static VALUE ruby_curl_easy_verbose_q(VALUE self) {
  CURB_BOOLEAN_GETTER(ruby_curl_easy, verbose);
}</pre>
          </div>
          
        </div>

        

        
      </div>

    
    </section>
  
  </section>
</main>


<footer id="validator-badges" role="contentinfo">
  <p><a href="https://validator.w3.org/check/referer">Validate</a>
  <p>Generated by <a href="https://ruby.github.io/rdoc/">RDoc</a> 6.0.1.
  <p>Based on <a href="http://deveiate.org/projects/Darkfish-RDoc/">Darkfish</a> by <a href="http://deveiate.org">Michael Granger</a>.
</footer>

